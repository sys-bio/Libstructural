# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_structural', [dirname(__file__)])
        except ImportError:
            import _structural
            return _structural
        if fp is not None:
            try:
                _mod = imp.load_module('_structural', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _structural = swig_import_helper()
    del swig_import_helper
else:
    import _structural
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _structural.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _structural.SwigPyIterator_value(self)
    def incr(self, n=1): return _structural.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _structural.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _structural.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _structural.SwigPyIterator_equal(self, *args)
    def copy(self): return _structural.SwigPyIterator_copy(self)
    def next(self): return _structural.SwigPyIterator_next(self)
    def __next__(self): return _structural.SwigPyIterator___next__(self)
    def previous(self): return _structural.SwigPyIterator_previous(self)
    def advance(self, *args): return _structural.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _structural.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _structural.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _structural.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _structural.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _structural.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _structural.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _structural.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringDouble(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringDouble, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _structural.new_StringDouble(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["first"] = _structural.StringDouble_first_set
    __swig_getmethods__["first"] = _structural.StringDouble_first_get
    if _newclass:first = _swig_property(_structural.StringDouble_first_get, _structural.StringDouble_first_set)
    __swig_setmethods__["second"] = _structural.StringDouble_second_set
    __swig_getmethods__["second"] = _structural.StringDouble_second_get
    if _newclass:second = _swig_property(_structural.StringDouble_second_get, _structural.StringDouble_second_set)
    def __len__(self): return 2
    def __repr__(self): return str((self.first, self.second))
    def __getitem__(self, index): 
      if not (index % 2): 
        return self.first
      else:
        return self.second
    def __setitem__(self, index, val):
      if not (index % 2): 
        self.first = val
      else:
        self.second = val
    __swig_destroy__ = _structural.delete_StringDouble
    __del__ = lambda self : None;
StringDouble_swigregister = _structural.StringDouble_swigregister
StringDouble_swigregister(StringDouble)

class StrDoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrDoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrDoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self): return _structural.StrDoubleVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _structural.StrDoubleVector___nonzero__(self)
    def __bool__(self): return _structural.StrDoubleVector___bool__(self)
    def __len__(self): return _structural.StrDoubleVector___len__(self)
    def pop(self): return _structural.StrDoubleVector_pop(self)
    def __getslice__(self, *args): return _structural.StrDoubleVector___getslice__(self, *args)
    def __setslice__(self, *args): return _structural.StrDoubleVector___setslice__(self, *args)
    def __delslice__(self, *args): return _structural.StrDoubleVector___delslice__(self, *args)
    def __delitem__(self, *args): return _structural.StrDoubleVector___delitem__(self, *args)
    def __getitem__(self, *args): return _structural.StrDoubleVector___getitem__(self, *args)
    def __setitem__(self, *args): return _structural.StrDoubleVector___setitem__(self, *args)
    def append(self, *args): return _structural.StrDoubleVector_append(self, *args)
    def empty(self): return _structural.StrDoubleVector_empty(self)
    def size(self): return _structural.StrDoubleVector_size(self)
    def clear(self): return _structural.StrDoubleVector_clear(self)
    def swap(self, *args): return _structural.StrDoubleVector_swap(self, *args)
    def get_allocator(self): return _structural.StrDoubleVector_get_allocator(self)
    def begin(self): return _structural.StrDoubleVector_begin(self)
    def end(self): return _structural.StrDoubleVector_end(self)
    def rbegin(self): return _structural.StrDoubleVector_rbegin(self)
    def rend(self): return _structural.StrDoubleVector_rend(self)
    def pop_back(self): return _structural.StrDoubleVector_pop_back(self)
    def erase(self, *args): return _structural.StrDoubleVector_erase(self, *args)
    def __init__(self, *args): 
        this = _structural.new_StrDoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _structural.StrDoubleVector_push_back(self, *args)
    def front(self): return _structural.StrDoubleVector_front(self)
    def back(self): return _structural.StrDoubleVector_back(self)
    def assign(self, *args): return _structural.StrDoubleVector_assign(self, *args)
    def resize(self, *args): return _structural.StrDoubleVector_resize(self, *args)
    def insert(self, *args): return _structural.StrDoubleVector_insert(self, *args)
    def reserve(self, *args): return _structural.StrDoubleVector_reserve(self, *args)
    def capacity(self): return _structural.StrDoubleVector_capacity(self)
    __swig_destroy__ = _structural.delete_StrDoubleVector
    __del__ = lambda self : None;
StrDoubleVector_swigregister = _structural.StrDoubleVector_swigregister
StrDoubleVector_swigregister(StrDoubleVector)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr
    def iterator(self): return _structural.StringVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _structural.StringVector___nonzero__(self)
    def __bool__(self): return _structural.StringVector___bool__(self)
    def __len__(self): return _structural.StringVector___len__(self)
    def pop(self): return _structural.StringVector_pop(self)
    def __getslice__(self, *args): return _structural.StringVector___getslice__(self, *args)
    def __setslice__(self, *args): return _structural.StringVector___setslice__(self, *args)
    def __delslice__(self, *args): return _structural.StringVector___delslice__(self, *args)
    def __delitem__(self, *args): return _structural.StringVector___delitem__(self, *args)
    def __getitem__(self, *args): return _structural.StringVector___getitem__(self, *args)
    def __setitem__(self, *args): return _structural.StringVector___setitem__(self, *args)
    def append(self, *args): return _structural.StringVector_append(self, *args)
    def empty(self): return _structural.StringVector_empty(self)
    def size(self): return _structural.StringVector_size(self)
    def clear(self): return _structural.StringVector_clear(self)
    def swap(self, *args): return _structural.StringVector_swap(self, *args)
    def get_allocator(self): return _structural.StringVector_get_allocator(self)
    def begin(self): return _structural.StringVector_begin(self)
    def end(self): return _structural.StringVector_end(self)
    def rbegin(self): return _structural.StringVector_rbegin(self)
    def rend(self): return _structural.StringVector_rend(self)
    def pop_back(self): return _structural.StringVector_pop_back(self)
    def erase(self, *args): return _structural.StringVector_erase(self, *args)
    def __init__(self, *args): 
        this = _structural.new_StringVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _structural.StringVector_push_back(self, *args)
    def front(self): return _structural.StringVector_front(self)
    def back(self): return _structural.StringVector_back(self)
    def assign(self, *args): return _structural.StringVector_assign(self, *args)
    def resize(self, *args): return _structural.StringVector_resize(self, *args)
    def insert(self, *args): return _structural.StringVector_insert(self, *args)
    def reserve(self, *args): return _structural.StringVector_reserve(self, *args)
    def capacity(self): return _structural.StringVector_capacity(self)
    __swig_destroy__ = _structural.delete_StringVector
    __del__ = lambda self : None;
StringVector_swigregister = _structural.StringVector_swigregister
StringVector_swigregister(StringVector)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self): return _structural.DoubleVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _structural.DoubleVector___nonzero__(self)
    def __bool__(self): return _structural.DoubleVector___bool__(self)
    def __len__(self): return _structural.DoubleVector___len__(self)
    def pop(self): return _structural.DoubleVector_pop(self)
    def __getslice__(self, *args): return _structural.DoubleVector___getslice__(self, *args)
    def __setslice__(self, *args): return _structural.DoubleVector___setslice__(self, *args)
    def __delslice__(self, *args): return _structural.DoubleVector___delslice__(self, *args)
    def __delitem__(self, *args): return _structural.DoubleVector___delitem__(self, *args)
    def __getitem__(self, *args): return _structural.DoubleVector___getitem__(self, *args)
    def __setitem__(self, *args): return _structural.DoubleVector___setitem__(self, *args)
    def append(self, *args): return _structural.DoubleVector_append(self, *args)
    def empty(self): return _structural.DoubleVector_empty(self)
    def size(self): return _structural.DoubleVector_size(self)
    def clear(self): return _structural.DoubleVector_clear(self)
    def swap(self, *args): return _structural.DoubleVector_swap(self, *args)
    def get_allocator(self): return _structural.DoubleVector_get_allocator(self)
    def begin(self): return _structural.DoubleVector_begin(self)
    def end(self): return _structural.DoubleVector_end(self)
    def rbegin(self): return _structural.DoubleVector_rbegin(self)
    def rend(self): return _structural.DoubleVector_rend(self)
    def pop_back(self): return _structural.DoubleVector_pop_back(self)
    def erase(self, *args): return _structural.DoubleVector_erase(self, *args)
    def __init__(self, *args): 
        this = _structural.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _structural.DoubleVector_push_back(self, *args)
    def front(self): return _structural.DoubleVector_front(self)
    def back(self): return _structural.DoubleVector_back(self)
    def assign(self, *args): return _structural.DoubleVector_assign(self, *args)
    def resize(self, *args): return _structural.DoubleVector_resize(self, *args)
    def insert(self, *args): return _structural.DoubleVector_insert(self, *args)
    def reserve(self, *args): return _structural.DoubleVector_reserve(self, *args)
    def capacity(self): return _structural.DoubleVector_capacity(self)
    __swig_destroy__ = _structural.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _structural.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class StringVectorx2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVectorx2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVectorx2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _structural.new_StringVectorx2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["first"] = _structural.StringVectorx2_first_set
    __swig_getmethods__["first"] = _structural.StringVectorx2_first_get
    if _newclass:first = _swig_property(_structural.StringVectorx2_first_get, _structural.StringVectorx2_first_set)
    __swig_setmethods__["second"] = _structural.StringVectorx2_second_set
    __swig_getmethods__["second"] = _structural.StringVectorx2_second_get
    if _newclass:second = _swig_property(_structural.StringVectorx2_second_get, _structural.StringVectorx2_second_set)
    def __len__(self): return 2
    def __repr__(self): return str((self.first, self.second))
    def __getitem__(self, index): 
      if not (index % 2): 
        return self.first
      else:
        return self.second
    def __setitem__(self, index, val):
      if not (index % 2): 
        self.first = val
      else:
        self.second = val
    __swig_destroy__ = _structural.delete_StringVectorx2
    __del__ = lambda self : None;
StringVectorx2_swigregister = _structural.StringVectorx2_swigregister
StringVectorx2_swigregister(StringVectorx2)

class DoubleMatrixStringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleMatrixStringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleMatrixStringVector, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _structural.new_DoubleMatrixStringVector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["first"] = _structural.DoubleMatrixStringVector_first_set
    __swig_getmethods__["first"] = _structural.DoubleMatrixStringVector_first_get
    if _newclass:first = _swig_property(_structural.DoubleMatrixStringVector_first_get, _structural.DoubleMatrixStringVector_first_set)
    __swig_setmethods__["second"] = _structural.DoubleMatrixStringVector_second_set
    __swig_getmethods__["second"] = _structural.DoubleMatrixStringVector_second_get
    if _newclass:second = _swig_property(_structural.DoubleMatrixStringVector_second_get, _structural.DoubleMatrixStringVector_second_set)
    def __len__(self): return 2
    def __repr__(self): return str((self.first, self.second))
    def __getitem__(self, index): 
      if not (index % 2): 
        return self.first
      else:
        return self.second
    def __setitem__(self, index, val):
      if not (index % 2): 
        self.first = val
      else:
        self.second = val
    __swig_destroy__ = _structural.delete_DoubleMatrixStringVector
    __del__ = lambda self : None;
DoubleMatrixStringVector_swigregister = _structural.DoubleMatrixStringVector_swigregister
DoubleMatrixStringVector_swigregister(DoubleMatrixStringVector)


def getVersion():
  return _structural.getVersion()
getVersion = _structural.getVersion
class LibStructural(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LibStructural, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LibStructural, name)
    __repr__ = _swig_repr
    def _my_loadStoichiometryMatrix(self, *args): return _structural.LibStructural__my_loadStoichiometryMatrix(self, *args)
    def _my_rref(self, *args): return _structural.LibStructural__my_rref(self, *args)
    def _my_rref_FB(self, *args): return _structural.LibStructural__my_rref_FB(self, *args)
    def loadSBMLFromString(self, *args):
        """
        LibStructural.loadSBMLFromString(self, *args)

        :param: SBML string to load
        :returns: information about the loaded model

        Loads SBML model from a valid string.


        """
        return _structural.LibStructural_loadSBMLFromString(self, *args)

    def loadSBMLFromFile(self, *args):
        """
        LibStructural.loadSBMLFromFile(self, *args)

        :param: sFileName a file name to a SBML file to load
        :returns: information about the loaded model

        Loads SBML model from the specified file.


        """
        return _structural.LibStructural_loadSBMLFromFile(self, *args)

    def loadSBMLwithTests(self, *args):
        """
        LibStructural.loadSBMLwithTests(self, *args)

        :param: a file name to of SBML model to load
        :returns: information about the loaded model and results of the internal test suite

        Loads an SBML model into the library and carry out tests using the internal test suite.


        """
        return _structural.LibStructural_loadSBMLwithTests(self, *args)

    def analyzeWithQR(self):
        """
        LibStructural.analyzeWithQR(self)

        Uses QR factorization for structural analysis. This method performs the actual analysis of the stoichiometry matrix loaded either via ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLUandRunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``


        Remarks: This is the prefered method for structural analysis.

        :returns: a result string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithQR(self)

    def analyzeWithLU(self):
        """
        LibStructural.analyzeWithLU(self)
        Uses LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix (loaded either via ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLUandRunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        :returns: a result string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithLU(self)

    def analyzeWithLUandRunTests(self):
        """
        LibStructural.analyzeWithLUandRunTests(self)
        Uses LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix loaded either via ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLUandRunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests''

        This method additionally performs the integrated test suite and returns	those results.

        :returns: a result string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithLUandRunTests(self)

    def analyzeWithFullyPivotedLU(self):
        """
        LibStructural.analyzeWithFullyPivotedLU(self)
        Uses fully pivoted LU Decomposition for Conservation analysis.This method performs the actual analysis of the stoichiometry matrix loaded either via ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``
        | ``LibStructural.analyzeWithLU``
        | ``LibStructural.analyzeWithLUandRunTests``
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        :returns: a result string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithFullyPivotedLU(self)

    def analyzeWithFullyPivotedLUwithTests(self):
        """
        LibStructural.analyzeWithFullyPivotedLUwithTests(self)
        Uses fully pivoted LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix loaded either via ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. Only after
        one of the analysis methods below has been called are the structural matrices (L0, K0...)
        available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLU``andRunTests,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        This method additionally performs the integrated test suite and returns	those results.

        :returns: a result string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithFullyPivotedLUwithTests(self)

    def _my_getL0Matrix(self): return _structural.LibStructural__my_getL0Matrix(self)
    def _my_getNrMatrix(self): return _structural.LibStructural__my_getNrMatrix(self)
    def _my_getFullyReorderedNrMatrix(self): return _structural.LibStructural__my_getFullyReorderedNrMatrix(self)
    def _my_getFullyReorderedN0StoichiometryMatrix(self): return _structural.LibStructural__my_getFullyReorderedN0StoichiometryMatrix(self)
    def _my_getColumnReorderedNrMatrix(self): return _structural.LibStructural__my_getColumnReorderedNrMatrix(self)
    def _my_getNICMatrix(self): return _structural.LibStructural__my_getNICMatrix(self)
    def _my_getNDCMatrix(self): return _structural.LibStructural__my_getNDCMatrix(self)
    def _my_getN0Matrix(self): return _structural.LibStructural__my_getN0Matrix(self)
    def _my_getK0Matrix(self): return _structural.LibStructural__my_getK0Matrix(self)
    def _my_getKMatrix(self): return _structural.LibStructural__my_getKMatrix(self)
    def _my_getGammaMatrix(self): return _structural.LibStructural__my_getGammaMatrix(self)
    def _my_getGammaMatrixGJ(self, *args): return _structural.LibStructural__my_getGammaMatrixGJ(self, *args)
    def _my_getStoichiometryMatrix(self): return _structural.LibStructural__my_getStoichiometryMatrix(self)
    def _my_getReorderedStoichiometryMatrix(self): return _structural.LibStructural__my_getReorderedStoichiometryMatrix(self)
    def _my_getFullyReorderedStoichiometryMatrix(self): return _structural.LibStructural__my_getFullyReorderedStoichiometryMatrix(self)
    def getReorderedSpecies(self):
        """
        LibStructural.getReorderedSpecies(self)

        :retruns: the reordered list of molecular species. (choosing the SBML Id if possible )


        """
        return _structural.LibStructural_getReorderedSpecies(self)

    def getSpecies(self):
        """
        LibStructural.getSpecies(self)

        :retruns: the unordered list of species Ids


        """
        return _structural.LibStructural_getSpecies(self)

    def getReorderedSpeciesNamesList(self):
        """
        LibStructural.getReorderedSpeciesNamesList(self)

        :retruns: the reordered list of molecular species.  (choosing the SBML Name if possible )


        """
        return _structural.LibStructural_getReorderedSpeciesNamesList(self)

    def getIndependentSpecies(self):
        """
        LibStructural.getIndependentSpecies(self)

        :retruns: the list of independent species


        """
        return _structural.LibStructural_getIndependentSpecies(self)

    def getIndependentSpeciesNamesList(self):
        """
        LibStructural.getIndependentSpeciesNamesList(self)

        :retruns: the actual names of the independent species


        """
        return _structural.LibStructural_getIndependentSpeciesNamesList(self)

    def getDependentSpecies(self):
        """
        LibStructural.getDependentSpecies(self)

        :retruns: the list of dependent species


        """
        return _structural.LibStructural_getDependentSpecies(self)

    def getDependentSpeciesNamesList(self):
        """
        LibStructural.getDependentSpeciesNamesList(self)

        :retruns: the actual names of the dependent species


        """
        return _structural.LibStructural_getDependentSpeciesNamesList(self)

    def getReactions(self):
        """
        LibStructural.getReactions(self)

        :retruns: the list of Reactions


        """
        return _structural.LibStructural_getReactions(self)

    def getIndependentReactionIds(self):
        """
        LibStructural.getIndependentReactionIds(self)

        :retruns: the list of independent reactions


        """
        return _structural.LibStructural_getIndependentReactionIds(self)

    def getDependentReactionIds(self):
        """
        LibStructural.getDependentReactionIds(self)

        :retruns: the list of dependent reactions



        """
        return _structural.LibStructural_getDependentReactionIds(self)

    def getReactionsNamesList(self):
        """
        LibStructural.getReactionsNamesList(self)

        :retruns: actual names of the Reactions


        """
        return _structural.LibStructural_getReactionsNamesList(self)

    def getReorderedReactions(self):
        """
        LibStructural.getReorderedReactions(self)

        :retruns: the reordered list of reactions


        """
        return _structural.LibStructural_getReorderedReactions(self)

    def getConservedLaws(self):
        """
        LibStructural.getConservedLaws(self)

        :retruns: algebraic expressions for conserved cycles


        """
        return _structural.LibStructural_getConservedLaws(self)

    def getConservedSums(self):
        """
        LibStructural.getConservedSums(self)

        :retruns: values for conservation laws using the current initial conditions


        """
        return _structural.LibStructural_getConservedSums(self)

    def getInitialConditions(self):
        """
        LibStructural.getInitialConditions(self)

        :retruns: Initial Conditions used in the model


        """
        return _structural.LibStructural_getInitialConditions(self)

    def validateStructuralMatrices(self):
        """
        LibStructural.validateStructuralMatrices(self)

        Validates structural matrices. Calling this method will run the internal test suite against the structural
        matrices those tests include:

        | Test 1 : Gamma*N = 0 (Zero matrix)
        | Test 2 : Rank(N) using SVD (5) is same as m0 (5)
        | Test 3 : Rank(NR) using SVD (5) is same as m0 (5)
        | Test 4 : Rank(NR) using QR (5) is same as m0 (5)
        | Test 5 : L0 obtained with QR matches Q21*inv(Q11)
        | Test 6 : N*K = 0 (Zero matrix)

        """
        return _structural.LibStructural_validateStructuralMatrices(self)

    def getTestDetails(self):
        """
        LibStructural.getTestDetails(self)

        :returns: Details about validation tests.


        """
        return _structural.LibStructural_getTestDetails(self)

    def getModelName(self):
        """
        LibStructural.getModelName(self)

        :retruns: the name of the model if SBML model has Name-tag, otherwise it returns the SBML id. If only a stoichiometry matrix was loaded 'untitled' will be returned.


        """
        return _structural.LibStructural_getModelName(self)

    def getNumSpecies(self):
        """
        LibStructural.getNumSpecies(self)

        :retruns: the total number of species


        """
        return _structural.LibStructural_getNumSpecies(self)

    def getNumIndSpecies(self):
        """
        LibStructural.getNumIndSpecies(self)

        :retruns: the number of independent species


        """
        return _structural.LibStructural_getNumIndSpecies(self)

    def getNumDepSpecies(self):
        """
        LibStructural.getNumDepSpecies(self)

        :retruns: the number of dependent species


        """
        return _structural.LibStructural_getNumDepSpecies(self)

    def getNumReactions(self):
        """
        LibStructural.getNumReactions(self)

        :retruns: the total number of reactions


        """
        return _structural.LibStructural_getNumReactions(self)

    def getNumIndReactions(self):
        """
        LibStructural.getNumIndReactions(self)

        :retruns: the number of independent reactions


        """
        return _structural.LibStructural_getNumIndReactions(self)

    def getNumDepReactions(self):
        """
        LibStructural.getNumDepReactions(self)

        :retruns: the number of dependent reactions


        """
        return _structural.LibStructural_getNumDepReactions(self)

    def getNmatrixSparsity(self):
        """
        LibStructural.getNmatrixSparsity(self)

        :retruns: the number of nonzero values in Stoichiometry matrix


        """
        return _structural.LibStructural_getNmatrixSparsity(self)

    def _my_getEigenValues(self, *args): return _structural.LibStructural__my_getEigenValues(self, *args)
    def _my_getEigenVectors(self, *args): return _structural.LibStructural__my_getEigenVectors(self, *args)
    def _my_getConditionNumber(self, *args): return _structural.LibStructural__my_getConditionNumber(self, *args)
    def _my_getLeftNullSpace(self, *args): return _structural.LibStructural__my_getLeftNullSpace(self, *args)
    def _my_getRightNullSpace(self, *args): return _structural.LibStructural__my_getRightNullSpace(self, *args)
    def _my_getRank(self, *args):
        """
        LibStructural.getRank(self);

        :param: Matrix to find the rank of.

        :retruns: the rank as an integer


        """
        return _structural.LibStructural__my_getRank(self, *args)

    def getRCond(self, *args):
        """
        LibStructural.getRCond(self, *args)



        """
        return _structural.LibStructural_getRCond(self, *args)

    def setTolerance(self, *args):
        """
        LibStructural.setTolerance(self, *args)

        :param:  an integer or float

        Sets user specified tolerance. This function sets the tolerance used by the library to determine what value is considered as zero. Any value with absolute value smaller than this tolerance is considered as zero and will be neglected.


        """
        return _structural.LibStructural_setTolerance(self, *args)

    def getTolerance(self):
        """
        LibStructural.getTolerance(self)

        :retruns: the currently used tolerance

        This function returns the tolerance currently used by the library to determine what value
        is considered as zero. Any value with absolute value smaller than this tolerance is considered zero
        and will be neglected.


        """
        return _structural.LibStructural_getTolerance(self)

    def __init__(self): 
        this = _structural.new_LibStructural()
        try: self.this.append(this)
        except: self.this = this
    def getInstance():
        """
        LibStructural.getInstance(self)

        static method to get an instance of LibStructural (allows use as singleton)


        """
        return _structural.LibStructural_getInstance()

    if _newclass:getInstance = staticmethod(getInstance)
    __swig_getmethods__["getInstance"] = lambda x: getInstance
    def getColumnReorderedNrMatrixLabels(self):
        """
        LibStructural.getColumnReorderedNrMatrixLabels(self)

        :retruns: the Nr Matrix row and column labels (repartitioned into NIC and NDC).


        """
        return _structural.LibStructural_getColumnReorderedNrMatrixLabels(self)

    def loadReactionNames(self, *args):
        """
        LibStructural.loadReactionNames(self, *args):

        :param: a vector of reaction names (ids)

        Loads reaction names. This function should be used whenever labeled matrices are important as these labels will be used in labeling the structural matrices. This function sets the reaction names (ids).

        Remarks: This method should only be called after ``LibStructural.loadStoichiometryMatrix``


        """
        return _structural.LibStructural_loadReactionNames(self, *args)

    def loadSpecies(self, *args):
        """
        LibStructural.loadSpecies(self, *args):

        :param: speciesNames a vector of species names (ids) to load
        :param: speciesValues a vector of initial concentrations

        Loads species names and initial values. This function should be used whenever labeled matrices are important as these labels will be used in labeling the structural matrices. This function sets the species names (ids). It is also possible to provide an initial condition for each of the species. This will be used when calculating the conserved sums.

        Remarks: This method should only be called after ``LibStructural.loadStoichiometryMatrix``


        """
        return _structural.LibStructural_loadSpecies(self, *args)

    def getGammaMatrixLabels(self):
        """
        LibStructural.getGammaMatrixLabels(self)

        :retruns: the row and column labels for Gamma, the conservation law array.

        """
        return _structural.LibStructural_getGammaMatrixLabels(self)

    def getK0MatrixLabels(self):
        """
        LibStructural.getK0MatrixLabels(self)

        :retruns: the K0 Matrix row and column labels.


        """
        return _structural.LibStructural_getK0MatrixLabels(self)

    def getKMatrixLabels(self):
        """
        LibStructural.getKMatrixLabels(self)

        :retruns: the K matrix row and column labels.


        """
        return _structural.LibStructural_getKMatrixLabels(self)

    def getL0MatrixLabels(self):
        """
        LibStructural.getL0MatrixLabels(self)

        :retruns: the L0 Matrix row and column labels.


        """
        return _structural.LibStructural_getL0MatrixLabels(self)

    def getLinkMatrixLabels(self):
        """
        LibStructural.getLinkMatrixLabels(self)

        :retruns: the row and column labels for the Link Matrix, L


        """
        return _structural.LibStructural_getLinkMatrixLabels(self)

    def getN0MatrixLabels(self):
        """
        LibStructural.getN0MatrixLabels(self)

        :retruns: the N0 Matrix row and column labels.


        """
        return _structural.LibStructural_getN0MatrixLabels(self)

    def getNDCMatrixLabels(self):
        """
        LibStructural.getNDCMatrixLabels(self)

        :retruns: the NDC Matrix row and column labels.


        """
        return _structural.LibStructural_getNDCMatrixLabels(self)

    def getNICMatrixLabels(self):
        """
        LibStructural.getNICMatrixLabels(self)

        :retruns: the NIC Matrix row and column labels.


        """
        return _structural.LibStructural_getNICMatrixLabels(self)

    def getNrMatrixLabels(self):
        """
        LibStructural.getNrMatrixLabels(self)

        :retruns: the Nr Matrix row and column labels.


        """
        return _structural.LibStructural_getNrMatrixLabels(self)

    def getStoichiometryMatrixLabels(self):
        """
        LibStructural.getStoichiometryMatrixLabels(self)

        :retruns: the row and column labels for the original and unaltered stoichiometry matrix.


        """
        return _structural.LibStructural_getStoichiometryMatrixLabels(self)

    def getFullyReorderedStoichiometryMatrixLabels(self):
        """
        LibStructural.getFullyReorderedStoichiometryMatrixLabels(self)

        :retruns: the row and column labels for the reordered stoichiometry matrix (row reordered stoichiometry matrix)


        """
        return _structural.LibStructural_getFullyReorderedStoichiometryMatrixLabels(self)

    def getReorderedStoichiometryMatrixLabels(self):
        """
        LibStructural.getReorderedStoichiometryMatrixLabels(self)

        :retruns: the row and column labels for the reordered stoichiometry matrix (row reordered stoichiometry matrix)


        """
        return _structural.LibStructural_getReorderedStoichiometryMatrixLabels(self)

    def getStoichiometryMatrix(self):
    	"""
    	LibStructural.getStoichiometryMatrix(self)
    	:returns: the original, unaltered stoichiometry matrix.
    	"""
    	return self._my_getStoichiometryMatrix().toNumpy()

    def getColumnReorderedNrMatrix(self):
    	"""
    	LibStructural.getColumnReorderedNrMatrix(self)
    	:returns: the Nr Matrix repartitioned into NIC (independent columns) and NDC (dependent columns).
    	"""
    	return self._my_getColumnReorderedNrMatrix().toNumpy()

    def getFullyReorderedN0StoichiometryMatrix(self):
    	"""
    	LibStructural.getFullyReorderedN0StoichiometryMatrix(self)
    	:returns: the N0 Matrix.
    	The rows of the Nr matrix will be linearly Dependent.
    	"""
    	return self._my_getFullyReorderedN0StoichiometryMatrix().toNumpy()

    def getFullyReorderedNrMatrix(self):
    	"""
    	LibStructural.getFullyReorderedNrMatrix(self)
    	:returns: the Nr Matrix.
    	"""
    	return self._my_getFullyReorderedNrMatrix().toNumpy()

    def getFullyReorderedStoichiometryMatrix(self):
    	"""
    	LibStructural.getFullyReorderedStoichiometryMatrix(self)
    	:returns: the fully reordered stoichiometry matrix (row and column reordered stoichiometry matrix)
    	"""
    	return self._my_getFullyReorderedStoichiometryMatrix().toNumpy()

    def getGammaMatrix(self):
    	"""
    	LibStructural.getGammaMatrix(self)
    	:returns: Gamma, the conservation law array.
    	Each row represents a single conservation law where the column indicate the participating molecular species. The number of rows is therefore equal to the number of conservation laws. Columns are ordered according to the rows in the reordered stoichiometry matrix, see LibStructural.getReorderedSpeciesId and LibStructural.getReorderedStoichiometryMatrix.

    	"""
    	return self._my_getGammaMatrix().toNumpy()

    def getGammaMatrixGJ(self,oMatrix):
    	"""
    	LibStructural.getGammaMatrixGJ(self,matrix)

    	:param: the stoichiometry matrix that will be used to calculate gamma
    	:returns: Gamma, the conservation law array.
    	Each row represents a single conservation law where the column indicate the participating molecular species. The number of rows is therefore equal to the number of conservation laws.
    	In this case the Gamma Matrix is recalculated for the given stoichiometry matrix.
    	Gamma is calculated based on R = GaussJordan ( [ stoichiometry  I ] ), where R has the form
    	R = [ R11 R12
    			0  GAMMA ]
    	The RowLabels should be an increasing number, to numerate the conservation law, the column label will be the same label as the stoichiometry matrix.
    	"""
    	import numpy as np

    	if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    		oMatrix = np.array(oMatrix)
    		if oMatrix.ndim == 2:
    			rows = len(oMatrix)
    			cols = len(oMatrix[0])
    			m = DoubleMatrix(rows,cols)
    			for i in range(rows):
    				for j in range (cols):
    					m.set (i, j, oMatrix[i][j])
    			return self._my_getGammaMatrixGJ(m).toNumpy()
    		else:
    			raise ValueError("Expecting 2 dimensional list or numpy array")
    	else:
    		raise ValueError("Expecting list or numpy array")


    def getK0Matrix(self):
    	"""
    	LibStructural.getK0Matrix(self)

    	:returns: the K0 Matrix.
    	K0 is defined such that K0 = -(NIC)\ :sup:`-1`\ * NDC, or equivalently, [NDC NIC][I K0]' = 0 where [NDC NIC] = Nr
    	"""
    	return self._my_getK0Matrix().toNumpy()

    def getKMatrix(self):
    	"""
    	LibStructural.getKMatrix(self)
    	:returns: the K matrix (right nullspace of Nr)
    	The K matrix has the structure, [I K0]'
    	"""
    	return self._my_getKMatrix().toNumpy()

    def getL0Matrix(self):
    	"""
    	LibStructural.getL0Matrix(self)

    	:returns: the L0 Matrix.

    	L0 is defined such that  L0*Nr = N0. L0 forms part of the link matrix, L.  N0 is the set of linear dependent rows from the lower portion of the reordered stoichiometry matrix.

    	"""
    	return self._my_getL0Matrix().toNumpy()

    def getLinkMatrix(self):
    	"""
    	LibStructural.getLinkMatrix(self)
    	:returns: L, the Link Matrix, left nullspace (aka nullspace of the transpose Nr).

    	L will have the structure, [I L0]', such that L*Nr = N
    	"""
    	return self.getLinkMatrix().toNumpy()

    def getN0Matrix(self):
    	"""
    	LibStructural.getN0Matrix(self)
    	:returns: the N0 Matrix.
    	The N0 matrix is the set of linearly dependent rows of N where L0 Nr = N0.
    	"""
    	return self._my_getN0Matrix().toNumpy()

    def getNDCMatrix(self):
    	"""
    	LibStructural.getNDCMatrix(self)
    	:returns: the NDC Matrix (the set of linearly dependent columns of Nr).

    	"""
    	return self._my_getNDCMatrix().toNumpy()

    def getNICMatrix(self):
    	"""
    	LibStructural.getNICMatrix(self)
    	:returns: the NIC Matrix (the set of linearly independent columns of Nr)
    	"""
    	return self._my_getNICMatrix().toNumpy()

    def getNrMatrix(self):
    	"""
    	LibStructural.getNrMatrix(self)

    	:returns: the Nr Matrix.

    	The rows of the Nr matrix will be linearly independent.
    	"""
    	return self._my_getNrMatrix().toNumpy()

    def getReorderedStoichiometryMatrix(self):
    	"""
    	LibStructural.getReorderedStoichiometryMatrix(self)

    	:returns: the reordered stoichiometry matrix (row reordered stoichiometry matrix, columns are not reordered!)

    	"""
    	return self._my_getReorderedStoichiometryMatrix().toNumpy()

    def loadStoichiometryMatrix(self, data):
    		"""
    		LibStructural.loadStoichiometryMatrix(self, Matrix)

    		:param: 2D array stoichiometry matrix

    		Loads a stoichiometry matrix into the library.
    		To analyze the stoichiometry call one of the following:

    		| ``LibStructural.analyzeWithQR``,
    		| ``LibStructural.analyzeWithLU``,
    		| ``LibStructural.analyzeWithLUandRunTests``,
    		| ``LibStructural.analyzeWithFullyPivotedLU``,
    		| ``LibStructural.analyzeWithFullyPivotedLUwithTests``,

    		Remarks: if matrix labels are needed it is recommended to call LibStructural.loadSpecies
    		and ``LibStructural.loadReactionNames``after a call to this method.

    		"""
    		import numpy as np

    		if (type(data) is list or type(data) is np.ndarray):
    			data = np.array(data)
    			if data.ndim == 2:
    				rows = len(data)
    				cols = len(data[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, data[i][j])
    				return self._my_loadStoichiometryMatrix (m)
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
    			raise ValueError("Expecting list or numpy array")

    def rref(self, data, tolerance=1e-6):
    		"""
    		LibStructural.rref(self, matrix, tol)

    		:param: a matrix and a tolerance value
    		:returns: reduced row echelon form of the matrix
    		"""
    		import numpy as np

    		if (type(data) is list or type(data) is np.ndarray):
    			data = np.array(data)
    			if data.ndim == 2:
    				rows = len(data)
    				cols = len(data[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, data[i][j])
    				return self._my_rref (m, tolerance).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def rref_FB(self, data, tolerance=1e-6):
    		import numpy as np

    		if (type(data) is list or type(data) is np.ndarray):
    			data = np.array(data)
    			if data.ndim == 2:
    				rows = len(data)
    				cols = len(data[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, data[i][j])
    				return self._my_rref_FB (m, tolerance).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getEigenValues (self, oMatrix):
    		"""
    		LibStructural.getEigenValues(self, matrix)

    		:param: Matrix to find the eigenvalues for
    		:returns: an array, first column are the real values and second column are imaginary values
    		"""

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getEigenValues(m).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getEigenVectors (self, oMatrix):
    		"""
    		LibStructural.getEigenVectors(self, matrix)

    		:param: Matrix to find the eigenvectors for
    		:returns: an array where each columns is an eigenvector
    		"""

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getEigenVectors(m).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getConditionNumber (self, oMatrix):
    		'''
    		LibStructural.getConditionNumber(self, matrix)

    		:param: Matrix to find the condition of
    		:returns: the condition numbe
    		'''
    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getConditionNumber(m)
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getRConditionNumber (self, oMatrix):


    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self.getRCond(m)
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getLeftNullSpace (self, oMatrix):
    		"""
    		LibStructural.getConditionNumber(self, matrix)

    		:param: Matrix to find the left nullspace of.
    		:returns: the Left Nullspace of the matrix argument

    		"""

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getLeftNullSpace(m).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getRightNullSpace (self, oMatrix):
    		"""
    		LibStructural.getRightNullSpace(self, matrix)

    		:param: Matrix to find the right nullspace of
    		:returns: the Right Nullspace of the matric argument
    		"""

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getRightNullSpace(m).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getRank (self, oMatrix):
    		"""
    		LibStructural.getRank(self, matrix)

    		:param: Matrix to find the rank of.
    		:returns: the rank as an integer
    		"""
    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getRank(m)
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    __swig_destroy__ = _structural.delete_LibStructural
    __del__ = lambda self : None;
LibStructural_swigregister = _structural.LibStructural_swigregister
LibStructural_swigregister(LibStructural)

def LibStructural_getInstance():
  """
    LibStructural.getInstance(self)

    static method to get an instance of LibStructural (allows use as singleton)


    """
  return _structural.LibStructural_getInstance()

class complexArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, complexArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, complexArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _structural.new_complexArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _structural.delete_complexArray
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _structural.complexArray___getitem__(self, *args)
    def __setitem__(self, *args): return _structural.complexArray___setitem__(self, *args)
    def cast(self): return _structural.complexArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _structural.complexArray_frompointer
    if _newclass:frompointer = staticmethod(_structural.complexArray_frompointer)
complexArray_swigregister = _structural.complexArray_swigregister
complexArray_swigregister(complexArray)

def complexArray_frompointer(*args):
  return _structural.complexArray_frompointer(*args)
complexArray_frompointer = _structural.complexArray_frompointer

class doubleArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _structural.new_doubleArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _structural.delete_doubleArray
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _structural.doubleArray___getitem__(self, *args)
    def __setitem__(self, *args): return _structural.doubleArray___setitem__(self, *args)
    def cast(self): return _structural.doubleArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _structural.doubleArray_frompointer
    if _newclass:frompointer = staticmethod(_structural.doubleArray_frompointer)
doubleArray_swigregister = _structural.doubleArray_swigregister
doubleArray_swigregister(doubleArray)

def doubleArray_frompointer(*args):
  return _structural.doubleArray_frompointer(*args)
doubleArray_frompointer = _structural.doubleArray_frompointer

class intArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _structural.new_intArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _structural.delete_intArray
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _structural.intArray___getitem__(self, *args)
    def __setitem__(self, *args): return _structural.intArray___setitem__(self, *args)
    def cast(self): return _structural.intArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _structural.intArray_frompointer
    if _newclass:frompointer = staticmethod(_structural.intArray_frompointer)
intArray_swigregister = _structural.intArray_swigregister
intArray_swigregister(intArray)

def intArray_frompointer(*args):
  return _structural.intArray_frompointer(*args)
intArray_frompointer = _structural.intArray_frompointer

class DoubleMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleMatrix, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_Rows"] = _structural.DoubleMatrix__Rows_set
    __swig_getmethods__["_Rows"] = _structural.DoubleMatrix__Rows_get
    if _newclass:_Rows = _swig_property(_structural.DoubleMatrix__Rows_get, _structural.DoubleMatrix__Rows_set)
    __swig_setmethods__["_Cols"] = _structural.DoubleMatrix__Cols_set
    __swig_getmethods__["_Cols"] = _structural.DoubleMatrix__Cols_get
    if _newclass:_Cols = _swig_property(_structural.DoubleMatrix__Cols_get, _structural.DoubleMatrix__Cols_set)
    __swig_setmethods__["_Array"] = _structural.DoubleMatrix__Array_set
    __swig_getmethods__["_Array"] = _structural.DoubleMatrix__Array_get
    if _newclass:_Array = _swig_property(_structural.DoubleMatrix__Array_get, _structural.DoubleMatrix__Array_set)
    def __init__(self, *args): 
        this = _structural.new_DoubleMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    def getArray(self): return _structural.DoubleMatrix_getArray(self)
    def getCopy(self, transpose=False): return _structural.DoubleMatrix_getCopy(self, transpose)
    def initializeFrom2DMatrix(self, *args): return _structural.DoubleMatrix_initializeFrom2DMatrix(self, *args)
    def initializeFromConst2DMatrix(self, *args): return _structural.DoubleMatrix_initializeFromConst2DMatrix(self, *args)
    __swig_destroy__ = _structural.delete_DoubleMatrix
    __del__ = lambda self : None;
    def get2DMatrix(self, *args): return _structural.DoubleMatrix_get2DMatrix(self, *args)
    def swapRows(self, *args): return _structural.DoubleMatrix_swapRows(self, *args)
    def swapCols(self, *args): return _structural.DoubleMatrix_swapCols(self, *args)
    def resize(self, *args): return _structural.DoubleMatrix_resize(self, *args)
    def getTranspose(self): return _structural.DoubleMatrix_getTranspose(self)
    def size(self): return _structural.DoubleMatrix_size(self)
    def numRows(self): return _structural.DoubleMatrix_numRows(self)
    def numCols(self): return _structural.DoubleMatrix_numCols(self)
    def __call__(self, *args): return _structural.DoubleMatrix___call__(self, *args)
    def get(self, *args): return _structural.DoubleMatrix_get(self, *args)
    def set(self, *args): return _structural.DoubleMatrix_set(self, *args)
    def toNumpy(self):
    		import numpy as np
    		result = np.zeros((self.numRows(), self.numCols()))
    		for i in range(self.numRows()):
    				for j in range(self.numCols()):
    						result[i,j] = self.get(i,j)
    		return result
    def __repr__(self):
    		return self.toNumpy().__repr__()

DoubleMatrix_swigregister = _structural.DoubleMatrix_swigregister
DoubleMatrix_swigregister(DoubleMatrix)

class IntMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntMatrix, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_Rows"] = _structural.IntMatrix__Rows_set
    __swig_getmethods__["_Rows"] = _structural.IntMatrix__Rows_get
    if _newclass:_Rows = _swig_property(_structural.IntMatrix__Rows_get, _structural.IntMatrix__Rows_set)
    __swig_setmethods__["_Cols"] = _structural.IntMatrix__Cols_set
    __swig_getmethods__["_Cols"] = _structural.IntMatrix__Cols_get
    if _newclass:_Cols = _swig_property(_structural.IntMatrix__Cols_get, _structural.IntMatrix__Cols_set)
    __swig_setmethods__["_Array"] = _structural.IntMatrix__Array_set
    __swig_getmethods__["_Array"] = _structural.IntMatrix__Array_get
    if _newclass:_Array = _swig_property(_structural.IntMatrix__Array_get, _structural.IntMatrix__Array_set)
    def __init__(self, *args): 
        this = _structural.new_IntMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    def getArray(self): return _structural.IntMatrix_getArray(self)
    def getCopy(self, transpose=False): return _structural.IntMatrix_getCopy(self, transpose)
    def initializeFrom2DMatrix(self, *args): return _structural.IntMatrix_initializeFrom2DMatrix(self, *args)
    def initializeFromConst2DMatrix(self, *args): return _structural.IntMatrix_initializeFromConst2DMatrix(self, *args)
    __swig_destroy__ = _structural.delete_IntMatrix
    __del__ = lambda self : None;
    def get2DMatrix(self, *args): return _structural.IntMatrix_get2DMatrix(self, *args)
    def swapRows(self, *args): return _structural.IntMatrix_swapRows(self, *args)
    def swapCols(self, *args): return _structural.IntMatrix_swapCols(self, *args)
    def resize(self, *args): return _structural.IntMatrix_resize(self, *args)
    def getTranspose(self): return _structural.IntMatrix_getTranspose(self)
    def size(self): return _structural.IntMatrix_size(self)
    def numRows(self): return _structural.IntMatrix_numRows(self)
    def numCols(self): return _structural.IntMatrix_numCols(self)
    def __call__(self, *args): return _structural.IntMatrix___call__(self, *args)
    def get(self, *args): return _structural.IntMatrix_get(self, *args)
    def set(self, *args): return _structural.IntMatrix_set(self, *args)
    def toNumpy(self):
    		import numpy as np
    		result = np.zeros((self.numRows(), self.numCols()), dtype=np.int)
    		for i in range(self.numRows()):
    				for j in range(self.numCols()):
    						result[i,j] = self.get(i,j)
    		return result
    def __repr__(self):
    		return self.toNumpy().__repr__()

IntMatrix_swigregister = _structural.IntMatrix_swigregister
IntMatrix_swigregister(IntMatrix)

class ComplexMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexMatrix, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_Rows"] = _structural.ComplexMatrix__Rows_set
    __swig_getmethods__["_Rows"] = _structural.ComplexMatrix__Rows_get
    if _newclass:_Rows = _swig_property(_structural.ComplexMatrix__Rows_get, _structural.ComplexMatrix__Rows_set)
    __swig_setmethods__["_Cols"] = _structural.ComplexMatrix__Cols_set
    __swig_getmethods__["_Cols"] = _structural.ComplexMatrix__Cols_get
    if _newclass:_Cols = _swig_property(_structural.ComplexMatrix__Cols_get, _structural.ComplexMatrix__Cols_set)
    __swig_setmethods__["_Array"] = _structural.ComplexMatrix__Array_set
    __swig_getmethods__["_Array"] = _structural.ComplexMatrix__Array_get
    if _newclass:_Array = _swig_property(_structural.ComplexMatrix__Array_get, _structural.ComplexMatrix__Array_set)
    def __init__(self, *args): 
        this = _structural.new_ComplexMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    def getArray(self): return _structural.ComplexMatrix_getArray(self)
    def getCopy(self, transpose=False): return _structural.ComplexMatrix_getCopy(self, transpose)
    def initializeFrom2DMatrix(self, *args): return _structural.ComplexMatrix_initializeFrom2DMatrix(self, *args)
    def initializeFromConst2DMatrix(self, *args): return _structural.ComplexMatrix_initializeFromConst2DMatrix(self, *args)
    __swig_destroy__ = _structural.delete_ComplexMatrix
    __del__ = lambda self : None;
    def get2DMatrix(self, *args): return _structural.ComplexMatrix_get2DMatrix(self, *args)
    def swapRows(self, *args): return _structural.ComplexMatrix_swapRows(self, *args)
    def swapCols(self, *args): return _structural.ComplexMatrix_swapCols(self, *args)
    def resize(self, *args): return _structural.ComplexMatrix_resize(self, *args)
    def getTranspose(self): return _structural.ComplexMatrix_getTranspose(self)
    def size(self): return _structural.ComplexMatrix_size(self)
    def numRows(self): return _structural.ComplexMatrix_numRows(self)
    def numCols(self): return _structural.ComplexMatrix_numCols(self)
    def __call__(self, *args): return _structural.ComplexMatrix___call__(self, *args)
    def get(self, *args): return _structural.ComplexMatrix_get(self, *args)
    def set(self, *args): return _structural.ComplexMatrix_set(self, *args)
    def toNumpy(self):
    		import numpy as np
    		result = np.zeros((self.numRows(), self.numCols()), dtype=np.complex_)
    		for i in range(self.numRows()):
    				for j in range(self.numCols()):
    						result[i,j] = self.getReal(i,j) + self.getImag(i,j)*1j
    		return result
    def __repr__(self):
    		return self.toNumpy().__repr__()

ComplexMatrix_swigregister = _structural.ComplexMatrix_swigregister
ComplexMatrix_swigregister(ComplexMatrix)

# This file is compatible with both classic and new-style classes.


