# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_structural')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_structural')
    _structural = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_structural', [dirname(__file__)])
        except ImportError:
            import _structural
            return _structural
        try:
            _mod = imp.load_module('_structural', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _structural = swig_import_helper()
    del swig_import_helper
else:
    import _structural
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _structural.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _structural.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _structural.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _structural.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _structural.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _structural.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _structural.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _structural.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _structural.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _structural.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _structural.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _structural.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _structural.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _structural.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _structural.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _structural.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _structural.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _structural.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringDouble(_object):
    """Proxy of C++ std::pair<(std::string,double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringDouble, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(std::string,double)> self) -> StringDouble
        __init__(std::pair<(std::string,double)> self, std::string first, double second) -> StringDouble
        __init__(std::pair<(std::string,double)> self, StringDouble p) -> StringDouble
        """
        this = _structural.new_StringDouble(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _structural.StringDouble_first_set
    __swig_getmethods__["first"] = _structural.StringDouble_first_get
    if _newclass:
        first = _swig_property(_structural.StringDouble_first_get, _structural.StringDouble_first_set)
    __swig_setmethods__["second"] = _structural.StringDouble_second_set
    __swig_getmethods__["second"] = _structural.StringDouble_second_get
    if _newclass:
        second = _swig_property(_structural.StringDouble_second_get, _structural.StringDouble_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _structural.delete_StringDouble
    __del__ = lambda self: None
StringDouble_swigregister = _structural.StringDouble_swigregister
StringDouble_swigregister(StringDouble)

class StrDoubleVector(_object):
    """Proxy of C++ std::vector<(std::pair<(std::string,double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrDoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrDoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(StrDoubleVector self) -> SwigPyIterator"""
        return _structural.StrDoubleVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(StrDoubleVector self) -> bool"""
        return _structural.StrDoubleVector___nonzero__(self)


    def __bool__(self):
        """__bool__(StrDoubleVector self) -> bool"""
        return _structural.StrDoubleVector___bool__(self)


    def __len__(self):
        """__len__(StrDoubleVector self) -> std::vector< std::pair< std::string,double > >::size_type"""
        return _structural.StrDoubleVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(StrDoubleVector self, std::vector< std::pair< std::string,double > >::difference_type i, std::vector< std::pair< std::string,double > >::difference_type j) -> StrDoubleVector"""
        return _structural.StrDoubleVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(StrDoubleVector self, std::vector< std::pair< std::string,double > >::difference_type i, std::vector< std::pair< std::string,double > >::difference_type j)
        __setslice__(StrDoubleVector self, std::vector< std::pair< std::string,double > >::difference_type i, std::vector< std::pair< std::string,double > >::difference_type j, StrDoubleVector v)
        """
        return _structural.StrDoubleVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(StrDoubleVector self, std::vector< std::pair< std::string,double > >::difference_type i, std::vector< std::pair< std::string,double > >::difference_type j)"""
        return _structural.StrDoubleVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(StrDoubleVector self, std::vector< std::pair< std::string,double > >::difference_type i)
        __delitem__(StrDoubleVector self, PySliceObject * slice)
        """
        return _structural.StrDoubleVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(StrDoubleVector self, PySliceObject * slice) -> StrDoubleVector
        __getitem__(StrDoubleVector self, std::vector< std::pair< std::string,double > >::difference_type i) -> StringDouble
        """
        return _structural.StrDoubleVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(StrDoubleVector self, PySliceObject * slice, StrDoubleVector v)
        __setitem__(StrDoubleVector self, PySliceObject * slice)
        __setitem__(StrDoubleVector self, std::vector< std::pair< std::string,double > >::difference_type i, StringDouble x)
        """
        return _structural.StrDoubleVector___setitem__(self, *args)


    def pop(self):
        """pop(StrDoubleVector self) -> StringDouble"""
        return _structural.StrDoubleVector_pop(self)


    def append(self, x):
        """append(StrDoubleVector self, StringDouble x)"""
        return _structural.StrDoubleVector_append(self, x)


    def empty(self):
        """empty(StrDoubleVector self) -> bool"""
        return _structural.StrDoubleVector_empty(self)


    def size(self):
        """size(StrDoubleVector self) -> std::vector< std::pair< std::string,double > >::size_type"""
        return _structural.StrDoubleVector_size(self)


    def swap(self, v):
        """swap(StrDoubleVector self, StrDoubleVector v)"""
        return _structural.StrDoubleVector_swap(self, v)


    def begin(self):
        """begin(StrDoubleVector self) -> std::vector< std::pair< std::string,double > >::iterator"""
        return _structural.StrDoubleVector_begin(self)


    def end(self):
        """end(StrDoubleVector self) -> std::vector< std::pair< std::string,double > >::iterator"""
        return _structural.StrDoubleVector_end(self)


    def rbegin(self):
        """rbegin(StrDoubleVector self) -> std::vector< std::pair< std::string,double > >::reverse_iterator"""
        return _structural.StrDoubleVector_rbegin(self)


    def rend(self):
        """rend(StrDoubleVector self) -> std::vector< std::pair< std::string,double > >::reverse_iterator"""
        return _structural.StrDoubleVector_rend(self)


    def clear(self):
        """clear(StrDoubleVector self)"""
        return _structural.StrDoubleVector_clear(self)


    def get_allocator(self):
        """get_allocator(StrDoubleVector self) -> std::vector< std::pair< std::string,double > >::allocator_type"""
        return _structural.StrDoubleVector_get_allocator(self)


    def pop_back(self):
        """pop_back(StrDoubleVector self)"""
        return _structural.StrDoubleVector_pop_back(self)


    def erase(self, *args):
        """
        erase(StrDoubleVector self, std::vector< std::pair< std::string,double > >::iterator pos) -> std::vector< std::pair< std::string,double > >::iterator
        erase(StrDoubleVector self, std::vector< std::pair< std::string,double > >::iterator first, std::vector< std::pair< std::string,double > >::iterator last) -> std::vector< std::pair< std::string,double > >::iterator
        """
        return _structural.StrDoubleVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::pair<(std::string,double)>)> self) -> StrDoubleVector
        __init__(std::vector<(std::pair<(std::string,double)>)> self, StrDoubleVector arg2) -> StrDoubleVector
        __init__(std::vector<(std::pair<(std::string,double)>)> self, std::vector< std::pair< std::string,double > >::size_type size) -> StrDoubleVector
        __init__(std::vector<(std::pair<(std::string,double)>)> self, std::vector< std::pair< std::string,double > >::size_type size, StringDouble value) -> StrDoubleVector
        """
        this = _structural.new_StrDoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(StrDoubleVector self, StringDouble x)"""
        return _structural.StrDoubleVector_push_back(self, x)


    def front(self):
        """front(StrDoubleVector self) -> StringDouble"""
        return _structural.StrDoubleVector_front(self)


    def back(self):
        """back(StrDoubleVector self) -> StringDouble"""
        return _structural.StrDoubleVector_back(self)


    def assign(self, n, x):
        """assign(StrDoubleVector self, std::vector< std::pair< std::string,double > >::size_type n, StringDouble x)"""
        return _structural.StrDoubleVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(StrDoubleVector self, std::vector< std::pair< std::string,double > >::size_type new_size)
        resize(StrDoubleVector self, std::vector< std::pair< std::string,double > >::size_type new_size, StringDouble x)
        """
        return _structural.StrDoubleVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(StrDoubleVector self, std::vector< std::pair< std::string,double > >::iterator pos, StringDouble x) -> std::vector< std::pair< std::string,double > >::iterator
        insert(StrDoubleVector self, std::vector< std::pair< std::string,double > >::iterator pos, std::vector< std::pair< std::string,double > >::size_type n, StringDouble x)
        """
        return _structural.StrDoubleVector_insert(self, *args)


    def reserve(self, n):
        """reserve(StrDoubleVector self, std::vector< std::pair< std::string,double > >::size_type n)"""
        return _structural.StrDoubleVector_reserve(self, n)


    def capacity(self):
        """capacity(StrDoubleVector self) -> std::vector< std::pair< std::string,double > >::size_type"""
        return _structural.StrDoubleVector_capacity(self)

    __swig_destroy__ = _structural.delete_StrDoubleVector
    __del__ = lambda self: None
StrDoubleVector_swigregister = _structural.StrDoubleVector_swigregister
StrDoubleVector_swigregister(StrDoubleVector)

class StringVector(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(StringVector self) -> SwigPyIterator"""
        return _structural.StringVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(StringVector self) -> bool"""
        return _structural.StringVector___nonzero__(self)


    def __bool__(self):
        """__bool__(StringVector self) -> bool"""
        return _structural.StringVector___bool__(self)


    def __len__(self):
        """__len__(StringVector self) -> std::vector< std::string >::size_type"""
        return _structural.StringVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> StringVector"""
        return _structural.StringVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, StringVector v)
        """
        return _structural.StringVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _structural.StringVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(StringVector self, std::vector< std::string >::difference_type i)
        __delitem__(StringVector self, PySliceObject * slice)
        """
        return _structural.StringVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(StringVector self, PySliceObject * slice) -> StringVector
        __getitem__(StringVector self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _structural.StringVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(StringVector self, PySliceObject * slice, StringVector v)
        __setitem__(StringVector self, PySliceObject * slice)
        __setitem__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _structural.StringVector___setitem__(self, *args)


    def pop(self):
        """pop(StringVector self) -> std::vector< std::string >::value_type"""
        return _structural.StringVector_pop(self)


    def append(self, x):
        """append(StringVector self, std::vector< std::string >::value_type const & x)"""
        return _structural.StringVector_append(self, x)


    def empty(self):
        """empty(StringVector self) -> bool"""
        return _structural.StringVector_empty(self)


    def size(self):
        """size(StringVector self) -> std::vector< std::string >::size_type"""
        return _structural.StringVector_size(self)


    def swap(self, v):
        """swap(StringVector self, StringVector v)"""
        return _structural.StringVector_swap(self, v)


    def begin(self):
        """begin(StringVector self) -> std::vector< std::string >::iterator"""
        return _structural.StringVector_begin(self)


    def end(self):
        """end(StringVector self) -> std::vector< std::string >::iterator"""
        return _structural.StringVector_end(self)


    def rbegin(self):
        """rbegin(StringVector self) -> std::vector< std::string >::reverse_iterator"""
        return _structural.StringVector_rbegin(self)


    def rend(self):
        """rend(StringVector self) -> std::vector< std::string >::reverse_iterator"""
        return _structural.StringVector_rend(self)


    def clear(self):
        """clear(StringVector self)"""
        return _structural.StringVector_clear(self)


    def get_allocator(self):
        """get_allocator(StringVector self) -> std::vector< std::string >::allocator_type"""
        return _structural.StringVector_get_allocator(self)


    def pop_back(self):
        """pop_back(StringVector self)"""
        return _structural.StringVector_pop_back(self)


    def erase(self, *args):
        """
        erase(StringVector self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(StringVector self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _structural.StringVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> StringVector
        __init__(std::vector<(std::string)> self, StringVector arg2) -> StringVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> StringVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> StringVector
        """
        this = _structural.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(StringVector self, std::vector< std::string >::value_type const & x)"""
        return _structural.StringVector_push_back(self, x)


    def front(self):
        """front(StringVector self) -> std::vector< std::string >::value_type const &"""
        return _structural.StringVector_front(self)


    def back(self):
        """back(StringVector self) -> std::vector< std::string >::value_type const &"""
        return _structural.StringVector_back(self)


    def assign(self, n, x):
        """assign(StringVector self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _structural.StringVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(StringVector self, std::vector< std::string >::size_type new_size)
        resize(StringVector self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _structural.StringVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(StringVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(StringVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _structural.StringVector_insert(self, *args)


    def reserve(self, n):
        """reserve(StringVector self, std::vector< std::string >::size_type n)"""
        return _structural.StringVector_reserve(self, n)


    def capacity(self):
        """capacity(StringVector self) -> std::vector< std::string >::size_type"""
        return _structural.StringVector_capacity(self)

    __swig_destroy__ = _structural.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _structural.StringVector_swigregister
StringVector_swigregister(StringVector)

class DoubleVector(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(DoubleVector self) -> SwigPyIterator"""
        return _structural.DoubleVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(DoubleVector self) -> bool"""
        return _structural.DoubleVector___nonzero__(self)


    def __bool__(self):
        """__bool__(DoubleVector self) -> bool"""
        return _structural.DoubleVector___bool__(self)


    def __len__(self):
        """__len__(DoubleVector self) -> std::vector< double >::size_type"""
        return _structural.DoubleVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DoubleVector"""
        return _structural.DoubleVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, DoubleVector v)
        """
        return _structural.DoubleVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _structural.DoubleVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(DoubleVector self, std::vector< double >::difference_type i)
        __delitem__(DoubleVector self, PySliceObject * slice)
        """
        return _structural.DoubleVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(DoubleVector self, PySliceObject * slice) -> DoubleVector
        __getitem__(DoubleVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _structural.DoubleVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(DoubleVector self, PySliceObject * slice, DoubleVector v)
        __setitem__(DoubleVector self, PySliceObject * slice)
        __setitem__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _structural.DoubleVector___setitem__(self, *args)


    def pop(self):
        """pop(DoubleVector self) -> std::vector< double >::value_type"""
        return _structural.DoubleVector_pop(self)


    def append(self, x):
        """append(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _structural.DoubleVector_append(self, x)


    def empty(self):
        """empty(DoubleVector self) -> bool"""
        return _structural.DoubleVector_empty(self)


    def size(self):
        """size(DoubleVector self) -> std::vector< double >::size_type"""
        return _structural.DoubleVector_size(self)


    def swap(self, v):
        """swap(DoubleVector self, DoubleVector v)"""
        return _structural.DoubleVector_swap(self, v)


    def begin(self):
        """begin(DoubleVector self) -> std::vector< double >::iterator"""
        return _structural.DoubleVector_begin(self)


    def end(self):
        """end(DoubleVector self) -> std::vector< double >::iterator"""
        return _structural.DoubleVector_end(self)


    def rbegin(self):
        """rbegin(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _structural.DoubleVector_rbegin(self)


    def rend(self):
        """rend(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _structural.DoubleVector_rend(self)


    def clear(self):
        """clear(DoubleVector self)"""
        return _structural.DoubleVector_clear(self)


    def get_allocator(self):
        """get_allocator(DoubleVector self) -> std::vector< double >::allocator_type"""
        return _structural.DoubleVector_get_allocator(self)


    def pop_back(self):
        """pop_back(DoubleVector self)"""
        return _structural.DoubleVector_pop_back(self)


    def erase(self, *args):
        """
        erase(DoubleVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DoubleVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _structural.DoubleVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> DoubleVector
        __init__(std::vector<(double)> self, DoubleVector arg2) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DoubleVector
        """
        this = _structural.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _structural.DoubleVector_push_back(self, x)


    def front(self):
        """front(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _structural.DoubleVector_front(self)


    def back(self):
        """back(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _structural.DoubleVector_back(self)


    def assign(self, n, x):
        """assign(DoubleVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _structural.DoubleVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(DoubleVector self, std::vector< double >::size_type new_size)
        resize(DoubleVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _structural.DoubleVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _structural.DoubleVector_insert(self, *args)


    def reserve(self, n):
        """reserve(DoubleVector self, std::vector< double >::size_type n)"""
        return _structural.DoubleVector_reserve(self, n)


    def capacity(self):
        """capacity(DoubleVector self) -> std::vector< double >::size_type"""
        return _structural.DoubleVector_capacity(self)

    __swig_destroy__ = _structural.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _structural.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class StringVectorx2(_object):
    """Proxy of C++ std::pair<(std::vector<(std::string)>,std::vector<(std::string)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVectorx2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVectorx2, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(std::vector<(std::string)>,std::vector<(std::string)>)> self) -> StringVectorx2
        __init__(std::pair<(std::vector<(std::string)>,std::vector<(std::string)>)> self, StringVector first, StringVector second) -> StringVectorx2
        __init__(std::pair<(std::vector<(std::string)>,std::vector<(std::string)>)> self, StringVectorx2 p) -> StringVectorx2
        """
        this = _structural.new_StringVectorx2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _structural.StringVectorx2_first_set
    __swig_getmethods__["first"] = _structural.StringVectorx2_first_get
    if _newclass:
        first = _swig_property(_structural.StringVectorx2_first_get, _structural.StringVectorx2_first_set)
    __swig_setmethods__["second"] = _structural.StringVectorx2_second_set
    __swig_getmethods__["second"] = _structural.StringVectorx2_second_get
    if _newclass:
        second = _swig_property(_structural.StringVectorx2_second_get, _structural.StringVectorx2_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _structural.delete_StringVectorx2
    __del__ = lambda self: None
StringVectorx2_swigregister = _structural.StringVectorx2_swigregister
StringVectorx2_swigregister(StringVectorx2)

class DoubleMatrixStringVector(_object):
    """Proxy of C++ std::pair<(p.LIB_LA::DoubleMatrix,std::vector<(std::string)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleMatrixStringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleMatrixStringVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(p.LIB_LA::DoubleMatrix,std::vector<(std::string)>)> self) -> DoubleMatrixStringVector
        __init__(std::pair<(p.LIB_LA::DoubleMatrix,std::vector<(std::string)>)> self, DoubleMatrix __a, StringVector __b) -> DoubleMatrixStringVector
        __init__(std::pair<(p.LIB_LA::DoubleMatrix,std::vector<(std::string)>)> self, DoubleMatrixStringVector __p) -> DoubleMatrixStringVector
        """
        this = _structural.new_DoubleMatrixStringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _structural.DoubleMatrixStringVector_first_set
    __swig_getmethods__["first"] = _structural.DoubleMatrixStringVector_first_get
    if _newclass:
        first = _swig_property(_structural.DoubleMatrixStringVector_first_get, _structural.DoubleMatrixStringVector_first_set)
    __swig_setmethods__["second"] = _structural.DoubleMatrixStringVector_second_set
    __swig_getmethods__["second"] = _structural.DoubleMatrixStringVector_second_get
    if _newclass:
        second = _swig_property(_structural.DoubleMatrixStringVector_second_get, _structural.DoubleMatrixStringVector_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _structural.delete_DoubleMatrixStringVector
    __del__ = lambda self: None
DoubleMatrixStringVector_swigregister = _structural.DoubleMatrixStringVector_swigregister
DoubleMatrixStringVector_swigregister(DoubleMatrixStringVector)


def getVersion():
    """getVersion() -> char *"""
    return _structural.getVersion()
class LibStructural(_object):
    """Proxy of C++ LIB_STRUCTURAL::LibStructural class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LibStructural, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LibStructural, name)
    __repr__ = _swig_repr

    def _my_loadStoichiometryMatrix(self, oMatrix):
        """_my_loadStoichiometryMatrix(LibStructural self, DoubleMatrix oMatrix)"""
        return _structural.LibStructural__my_loadStoichiometryMatrix(self, oMatrix)


    def _my_rref(self, oMatrix, tolerance):
        """_my_rref(LibStructural self, DoubleMatrix oMatrix, double tolerance) -> DoubleMatrix"""
        return _structural.LibStructural__my_rref(self, oMatrix, tolerance)


    def _my_rref_FB(self, oMatrix, tolerance):
        """_my_rref_FB(LibStructural self, DoubleMatrix oMatrix, double tolerance) -> DoubleMatrix"""
        return _structural.LibStructural__my_rref_FB(self, oMatrix, tolerance)


    def loadSBMLFromString(self, sSBML):
        """
        loadSBMLFromString(LibStructural self, std::string sSBML) -> std::string


        LibStructural.loadSBMLFromString(self, *args)

        :param: SBML string to load
        :returns: information about the loaded model

        Loads SBML model from a string variable.


        """
        return _structural.LibStructural_loadSBMLFromString(self, sSBML)


    def loadSBMLFromFile(self, sFileName):
        """
        loadSBMLFromFile(LibStructural self, std::string sFileName) -> std::string


        LibStructural.loadSBMLFromFile(self, *args)

        :param: sFileName a file name to a SBML file to load
        :returns: information about the loaded model

        Loads SBML model from the specified file.


        """
        return _structural.LibStructural_loadSBMLFromFile(self, sFileName)


    def loadSBMLwithTests(self, sSBML):
        """
        loadSBMLwithTests(LibStructural self, std::string sSBML) -> std::string


        LibStructural.loadSBMLwithTests(self, *args)

        :param: a file name to an SBML model to load.
        :returns: information about the loaded model and results of the internal test suite.

        Loads an SBML model into the library and carries out tests using the internal test suite.


        """
        return _structural.LibStructural_loadSBMLwithTests(self, sSBML)


    def analyzeWithQR(self):
        """
        analyzeWithQR(LibStructural self) -> std::string


        LibStructural.analyzeWithQR(self)

        Uses QR factorization for structural analysis. This method performs the actual analysis of the stoichiometry matrix loaded 
        either via 

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. 

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLU``,
          ``RunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU``,
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``


        Remarks: This is the prefered method for structural analysis.

        :returns: a string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithQR(self)


    def analyzeWithLU(self):
        """
        analyzeWithLU(LibStructural self) -> std::string


        LibStructural.analyzeWithLU(self)
        Uses LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix (loaded either 
        via 

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. 

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLUandRunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        :returns: a string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithLU(self)


    def analyzeWithLUandRunTests(self):
        """
        analyzeWithLUandRunTests(LibStructural self) -> std::string


        LibStructural.analyzeWithLUandRunTests(self)
        Uses LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix loaded either 
        via 

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. 

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLUandRunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests''

        This method additionally performs the integrated test suite and returns	those results.

        :returns: a string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithLUandRunTests(self)


    def analyzeWithFullyPivotedLU(self):
        """
        analyzeWithFullyPivotedLU(LibStructural self) -> std::string


        LibStructural.analyzeWithFullyPivotedLU(self)
        Uses fully pivoted LU Decomposition for Conservation analysis.This method performs the actual analysis of the stoichiometry matrix loaded either 
        via 

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. 

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``
        | ``LibStructural.analyzeWithLU``
        | ``LibStructural.analyzeWithLUandRunTests``
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        :returns: a string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithFullyPivotedLU(self)


    def analyzeWithFullyPivotedLUwithTests(self):
        """
        analyzeWithFullyPivotedLUwithTests(LibStructural self) -> std::string


        LibStructural.analyzeWithFullyPivotedLUwithTests(self)
        Uses fully pivoted LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix loaded 
        either via 

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``. 

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLU``andRunTests,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        This method additionally performs the integrated test suite and returns	those results.

        :returns: a string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithFullyPivotedLUwithTests(self)


    def _my_getL0Matrix(self):
        """_my_getL0Matrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getL0Matrix(self)


    def _my_getNrMatrix(self):
        """_my_getNrMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getNrMatrix(self)


    def _my_getFullyReorderedNrMatrix(self):
        """_my_getFullyReorderedNrMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getFullyReorderedNrMatrix(self)


    def _my_getFullyReorderedN0StoichiometryMatrix(self):
        """_my_getFullyReorderedN0StoichiometryMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getFullyReorderedN0StoichiometryMatrix(self)


    def _my_getColumnReorderedNrMatrix(self):
        """_my_getColumnReorderedNrMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getColumnReorderedNrMatrix(self)


    def _my_getNICMatrix(self):
        """_my_getNICMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getNICMatrix(self)


    def _my_getNDCMatrix(self):
        """_my_getNDCMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getNDCMatrix(self)


    def _my_getN0Matrix(self):
        """_my_getN0Matrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getN0Matrix(self)


    def _my_getK0Matrix(self):
        """_my_getK0Matrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getK0Matrix(self)


    def _my_getKMatrix(self):
        """_my_getKMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getKMatrix(self)


    def _my_getGammaMatrix(self):
        """_my_getGammaMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getGammaMatrix(self)


    def _my_getGammaMatrixGJ(self, stoichiometry):
        """_my_getGammaMatrixGJ(LibStructural self, DoubleMatrix stoichiometry) -> DoubleMatrix"""
        return _structural.LibStructural__my_getGammaMatrixGJ(self, stoichiometry)


    def _my_getStoichiometryMatrix(self):
        """_my_getStoichiometryMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getStoichiometryMatrix(self)


    def _my_getReorderedStoichiometryMatrix(self):
        """_my_getReorderedStoichiometryMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getReorderedStoichiometryMatrix(self)


    def _my_getFullyReorderedStoichiometryMatrix(self):
        """_my_getFullyReorderedStoichiometryMatrix(LibStructural self) -> DoubleMatrix"""
        return _structural.LibStructural__my_getFullyReorderedStoichiometryMatrix(self)


    def getReorderedSpecies(self):
        """
        getReorderedSpecies(LibStructural self) -> StringVector


        LibStructural.getReorderedSpecies(self)

        :returns: the reordered list of molecular species (choosing the SBML Id if possible).


        """
        return _structural.LibStructural_getReorderedSpecies(self)


    def getSpecies(self):
        """
        getSpecies(LibStructural self) -> StringVector


        LibStructural.getSpecies(self)

        :returns: the unordered list of species Ids.


        """
        return _structural.LibStructural_getSpecies(self)


    def getReorderedSpeciesNamesList(self):
        """
        getReorderedSpeciesNamesList(LibStructural self) -> StringVector


        LibStructural.getReorderedSpeciesNamesList(self)

        :returns: the reordered list of molecular species (choosing the SBML Name if possible).


        """
        return _structural.LibStructural_getReorderedSpeciesNamesList(self)


    def getIndependentSpecies(self):
        """
        getIndependentSpecies(LibStructural self) -> StringVector


        LibStructural.getIndependentSpecies(self)

        :returns: the list of Ids for the independent species.


        """
        return _structural.LibStructural_getIndependentSpecies(self)


    def getIndependentSpeciesNamesList(self):
        """
        getIndependentSpeciesNamesList(LibStructural self) -> StringVector


        LibStructural.getIndependentSpeciesNamesList(self)

        :returns: the actual names of the independent species.


        """
        return _structural.LibStructural_getIndependentSpeciesNamesList(self)


    def getDependentSpecies(self):
        """
        getDependentSpecies(LibStructural self) -> StringVector


        LibStructural.getDependentSpecies(self)

        :returns: the list of Ids for the dependent species.


        """
        return _structural.LibStructural_getDependentSpecies(self)


    def getDependentSpeciesNamesList(self):
        """
        getDependentSpeciesNamesList(LibStructural self) -> StringVector


        LibStructural.getDependentSpeciesNamesList(self)

        :returns: the display names of the dependent species.


        """
        return _structural.LibStructural_getDependentSpeciesNamesList(self)


    def getReactions(self):
        """
        getReactions(LibStructural self) -> StringVector


        LibStructural.getReactions(self)

        :returns: the list of Reactions.


        """
        return _structural.LibStructural_getReactions(self)


    def getIndependentReactionIds(self):
        """
        getIndependentReactionIds(LibStructural self) -> StringVector


        LibStructural.getIndependentReactionIds(self)

        :returns: the list of Ids for the independent reactions.


        """
        return _structural.LibStructural_getIndependentReactionIds(self)


    def getDependentReactionIds(self):
        """
        getDependentReactionIds(LibStructural self) -> StringVector


        LibStructural.getDependentReactionIds(self)

        :returns: the list of Ids for the dependent reactions.



        """
        return _structural.LibStructural_getDependentReactionIds(self)


    def getReactionsNamesList(self):
        """
        getReactionsNamesList(LibStructural self) -> StringVector


        LibStructural.getReactionsNamesList(self)

        :returns: display names of the reactions.


        """
        return _structural.LibStructural_getReactionsNamesList(self)


    def getReorderedReactions(self):
        """
        getReorderedReactions(LibStructural self) -> StringVector


        LibStructural.getReorderedReactions(self)

        :returns: the reordered Id list of reactions.


        """
        return _structural.LibStructural_getReorderedReactions(self)


    def getConservedLaws(self):
        """
        getConservedLaws(LibStructural self) -> StringVector


        LibStructural.getConservedLaws(self)

        :returns: algebraic expressions for the conserved cycles. Returns empty if none.


        """
        return _structural.LibStructural_getConservedLaws(self)


    def getConservedSums(self):
        """
        getConservedSums(LibStructural self) -> DoubleVector


        LibStructural.getConservedSums(self)

        :returns: Total mass for each conserved cycle in the model. The sum is based on the current initial conditions.


        """
        return _structural.LibStructural_getConservedSums(self)


    def getInitialConditions(self):
        """
        getInitialConditions(LibStructural self) -> StrDoubleVector


        LibStructural.getInitialConditions(self)

        :returns: Initial Conditions used in the model.


        """
        return _structural.LibStructural_getInitialConditions(self)


    def validateStructuralMatrices(self):
        """
        validateStructuralMatrices(LibStructural self) -> StringVector


        LibStructural.validateStructuralMatrices(self)

        Validates structural matrices. Calling this method will run the internal test suite against the structural
        matrices those tests include:

        | Test 1 : Gamma*N = 0 (Zero matrix)
        | Test 2 : Rank(N) using SVD (5) is same as m0 (5)
        | Test 3 : Rank(NR) using SVD (5) is same as m0 (5)
        | Test 4 : Rank(NR) using QR (5) is same as m0 (5)
        | Test 5 : L0 obtained with QR matches Q21*inv(Q11)
        | Test 6 : N*K = 0 (Zero matrix)

        """
        return _structural.LibStructural_validateStructuralMatrices(self)


    def getTestDetails(self):
        """
        getTestDetails(LibStructural self) -> std::string


        LibStructural.getTestDetails(self)

        :returns: Details about the validation tests.


        """
        return _structural.LibStructural_getTestDetails(self)


    def getModelName(self):
        """
        getModelName(LibStructural self) -> std::string


        LibStructural.getModelName(self)

        :returns: the name of the model if SBML model has Name-tag, otherwise it returns the SBML id. If only a stoichiometry matrix was loaded 'untitled' will be returned.


        """
        return _structural.LibStructural_getModelName(self)


    def getNumSpecies(self):
        """
        getNumSpecies(LibStructural self) -> int


        LibStructural.getNumSpecies(self)

        :returns: the total number of species


        """
        return _structural.LibStructural_getNumSpecies(self)


    def getNumIndSpecies(self):
        """
        getNumIndSpecies(LibStructural self) -> int


        LibStructural.getNumIndSpecies(self)

        :returns: the number of independent species.


        """
        return _structural.LibStructural_getNumIndSpecies(self)


    def getNumDepSpecies(self):
        """
        getNumDepSpecies(LibStructural self) -> int


        LibStructural.getNumDepSpecies(self)

        :returns: the number of dependent species.


        """
        return _structural.LibStructural_getNumDepSpecies(self)


    def getNumReactions(self):
        """
        getNumReactions(LibStructural self) -> int


        LibStructural.getNumReactions(self)

        :returns: the total number of reactions.


        """
        return _structural.LibStructural_getNumReactions(self)


    def getNumIndReactions(self):
        """
        getNumIndReactions(LibStructural self) -> int


        LibStructural.getNumIndReactions(self)

        :returns: the number of independent reactions


        """
        return _structural.LibStructural_getNumIndReactions(self)


    def getNumDepReactions(self):
        """
        getNumDepReactions(LibStructural self) -> int


        LibStructural.getNumDepReactions(self)

        :returns: the number of dependent reactions


        """
        return _structural.LibStructural_getNumDepReactions(self)


    def getNmatrixSparsity(self):
        """
        getNmatrixSparsity(LibStructural self) -> double


        LibStructural.getNmatrixSparsity(self)

        :returns: the number of nonzero values in Stoichiometry matrix


        """
        return _structural.LibStructural_getNmatrixSparsity(self)


    def _my_getEigenValues(self, oMatrix):
        """_my_getEigenValues(LibStructural self, DoubleMatrix oMatrix) -> DoubleMatrix"""
        return _structural.LibStructural__my_getEigenValues(self, oMatrix)


    def _my_getEigenVectors(self, oMatrix):
        """_my_getEigenVectors(LibStructural self, DoubleMatrix oMatrix) -> DoubleMatrix"""
        return _structural.LibStructural__my_getEigenVectors(self, oMatrix)


    def _my_getConditionNumber(self, oMatrix):
        """_my_getConditionNumber(LibStructural self, DoubleMatrix oMatrix) -> double"""
        return _structural.LibStructural__my_getConditionNumber(self, oMatrix)


    def _my_getLeftNullSpace(self, oMatrix):
        """_my_getLeftNullSpace(LibStructural self, DoubleMatrix oMatrix) -> DoubleMatrix"""
        return _structural.LibStructural__my_getLeftNullSpace(self, oMatrix)


    def _my_getRightNullSpace(self, oMatrix):
        """_my_getRightNullSpace(LibStructural self, DoubleMatrix oMatrix) -> DoubleMatrix"""
        return _structural.LibStructural__my_getRightNullSpace(self, oMatrix)


    def _my_getRank(self, *args):
        """
        _my_getRank(LibStructural self) -> int
        _my_getRank(LibStructural self, DoubleMatrix oMatrix) -> int


        LibStructural.getRank(self);

        :param: Matrix to find the rank of.

        :returns: the rank as an integer


        """
        return _structural.LibStructural__my_getRank(self, *args)


    def getRCond(self, oMatrix):
        """
        getRCond(LibStructural self, DoubleMatrix oMatrix) -> double


        LibStructural.getRCond(self, *args)



        """
        return _structural.LibStructural_getRCond(self, oMatrix)


    def setTolerance(self, dTolerance):
        """
        setTolerance(LibStructural self, double dTolerance)


        LibStructural.setTolerance(self, *args)

        :param:  an integer or float

        Sets user specified tolerance. This function sets the tolerance used by the library to determine what value is considered as zero. Any value with absolute value smaller than this tolerance is considered as zero and will be neglected.


        """
        return _structural.LibStructural_setTolerance(self, dTolerance)


    def getTolerance(self):
        """
        getTolerance(LibStructural self) -> double


        LibStructural.getTolerance(self)

        :returns: the currently used tolerance for decided whether a small number is considered zero or not. 

        This function returns the tolerance currently used by the library to determine what value
        is considered as zero. Any value with absolute value smaller than this tolerance is considered zero
        and will be neglected.


        """
        return _structural.LibStructural_getTolerance(self)


    def __init__(self):
        """__init__(LIB_STRUCTURAL::LibStructural self) -> LibStructural"""
        this = _structural.new_LibStructural()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getInstance():
        """
        getInstance() -> LibStructural


        LibStructural.getInstance(self)

        static method to get an instance of LibStructural (allows use as singleton)

         import structural 
         ls = structural.LibStructural.getInstance()

        """
        return _structural.LibStructural_getInstance()

    getInstance = staticmethod(getInstance)

    def getColumnReorderedNrMatrixLabels(self):
        """
        getColumnReorderedNrMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getColumnReorderedNrMatrixLabels(self)

        :returns: the Nr Matrix row and column labels (repartitioned into NIC and NDC).


        """
        return _structural.LibStructural_getColumnReorderedNrMatrixLabels(self)


    def loadReactionNames(self, *args):
        """
        loadReactionNames(LibStructural self, StringVector reactionNames)
        loadReactionNames(LibStructural self, StringVector reactionNames)


        LibStructural.loadReactionNames(self, *args):

        :param: a vector of reaction names (ids)

        Loads reaction names. This function should be used whenever labeled matrices are important as these labels will be used in labeling the structural matrices. This function sets the reaction names (ids).

        Remarks: This method should only be called after ``LibStructural.loadStoichiometryMatrix``


        """
        return _structural.LibStructural_loadReactionNames(self, *args)


    def loadSpecies(self, *args):
        """
        loadSpecies(LibStructural self, StringVector speciesNames, DoubleVector speciesValues)
        loadSpecies(LibStructural self, StringVector speciesNames, DoubleVector speciesValues)


        LibStructural.loadSpecies(self, *args):

        :param: speciesNames a vector of species names (ids) to load
        :param: speciesValues a vector of initial concentrations

        Loads species names and initial values. This function should be used whenever labeled matrices are important as these labels will be used in labeling the structural matrices. This function sets the species names (ids). It is also possible to provide an initial condition for each of the species. This will be used when calculating the conserved sums.

        Remarks: This method should only be called after ``LibStructural.loadStoichiometryMatrix``


        """
        return _structural.LibStructural_loadSpecies(self, *args)


    def getGammaMatrixLabels(self):
        """
        getGammaMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getGammaMatrixLabels(self)

        :returns: the row and column labels for Gamma, the conservation law array.

        """
        return _structural.LibStructural_getGammaMatrixLabels(self)


    def getK0MatrixLabels(self):
        """
        getK0MatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getK0MatrixLabels(self)

        :returns: the K0 Matrix row and column labels.


        """
        return _structural.LibStructural_getK0MatrixLabels(self)


    def getKMatrixLabels(self):
        """
        getKMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getKMatrixLabels(self)

        :returns: the K matrix row and column labels.


        """
        return _structural.LibStructural_getKMatrixLabels(self)


    def getL0MatrixLabels(self):
        """
        getL0MatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getL0MatrixLabels(self)

        :returns: the L0 Matrix row and column labels.


        """
        return _structural.LibStructural_getL0MatrixLabels(self)


    def getLinkMatrixLabels(self):
        """
        getLinkMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getLinkMatrixLabels(self)

        :returns: the row and column labels for the Link Matrix, L


        """
        return _structural.LibStructural_getLinkMatrixLabels(self)


    def getN0MatrixLabels(self):
        """
        getN0MatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getN0MatrixLabels(self)

        :returns: the N0 Matrix row and column labels.


        """
        return _structural.LibStructural_getN0MatrixLabels(self)


    def getNDCMatrixLabels(self):
        """
        getNDCMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getNDCMatrixLabels(self)

        :returns: the NDC Matrix row and column labels.


        """
        return _structural.LibStructural_getNDCMatrixLabels(self)


    def getNICMatrixLabels(self):
        """
        getNICMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getNICMatrixLabels(self)

        :returns: the NIC Matrix row and column labels.


        """
        return _structural.LibStructural_getNICMatrixLabels(self)


    def getNrMatrixLabels(self):
        """
        getNrMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getNrMatrixLabels(self)

        :returns: the Nr Matrix row and column labels.


        """
        return _structural.LibStructural_getNrMatrixLabels(self)


    def getStoichiometryMatrixLabels(self):
        """
        getStoichiometryMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getStoichiometryMatrixLabels(self)

        :returns: the row and column labels for the original and unaltered stoichiometry matrix.


        """
        return _structural.LibStructural_getStoichiometryMatrixLabels(self)


    def getFullyReorderedStoichiometryMatrixLabels(self):
        """
        getFullyReorderedStoichiometryMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getFullyReorderedStoichiometryMatrixLabels(self)

        :returns: the row and column labels for the reordered stoichiometry matrix (row reordered stoichiometry matrix)


        """
        return _structural.LibStructural_getFullyReorderedStoichiometryMatrixLabels(self)


    def getReorderedStoichiometryMatrixLabels(self):
        """
        getReorderedStoichiometryMatrixLabels(LibStructural self) -> StringVectorx2


        LibStructural.getReorderedStoichiometryMatrixLabels(self)

        :returns: the row and column labels for the reordered stoichiometry matrix (row reordered stoichiometry matrix)


        """
        return _structural.LibStructural_getReorderedStoichiometryMatrixLabels(self)


    def getStoichiometryMatrix(self):
       """
       LibStructural.getStoichiometryMatrix(self)
       :returns: Unaltered stoichiometry matrix.
       """
       return self._my_getStoichiometryMatrix().toNumpy();


    def getColumnReorderedNrMatrix(self):
    	"""
    	LibStructural.getColumnReorderedNrMatrix(self)
    	:returns: the Nr Matrix repartitioned into NIC (independent columns) and NDC (dependent columns). The Nr matrix contains the independent rows of the stoichiometry matrix
    	"""
    	return self._my_getColumnReorderedNrMatrix().toNumpy()

    def getFullyReorderedN0StoichiometryMatrix(self):
    	"""
    	LibStructural.getFullyReorderedN0StoichiometryMatrix(self)

    	Computes the N0 matrix if possible. The N0 matrix will contain all the dependent rows of the stoichiometry matrix.

    	:returns: the N0 Matrix.

    	"""
    	return self._my_getFullyReorderedN0StoichiometryMatrix().toNumpy()

    def getFullyReorderedNrMatrix(self):
    	"""
    	LibStructural.getFullyReorderedNrMatrix(self)

    	The Nr matrix contains all the linearly independent rows of the stoichiometry matrix.

    	:returns: the Nr Matrix.
    	"""
    	return self._my_getFullyReorderedNrMatrix().toNumpy()

    def getFullyReorderedStoichiometryMatrix(self):
    	"""
    	LibStructural.getFullyReorderedStoichiometryMatrix(self)
    	:returns: the fully reordered stoichiometry matrix. Rows and columns are reordered so all indepedent rows
    	of the stoichiometry matrix are brought to the top and left side of the matrix.
    	"""
    	return self._my_getFullyReorderedStoichiometryMatrix().toNumpy()

    def getGammaMatrix(self):
    	"""
    	LibStructural.getGammaMatrix(self)
    	:returns: Gamma, the conservation law array.
    	Each row represents a single conservation law where the column indicates the participating molecular species.
    	The number of rows is therefore equal to the number of conservation laws. Columns are ordered according to the
    	rows in the reordered stoichiometry matrix, see ``LibStructural.getReorderedSpeciesId`` and ``LibStructural.getReorderedStoichiometryMatrix``.

    	"""
    	return self._my_getGammaMatrix().toNumpy()

    def getGammaMatrixGJ(self, oMatrix):
    	"""
    	LibStructural.getGammaMatrixGJ(self,matrix)

    	:param: the stoichiometry matrix that will be used to calculate gamma
    	:returns: Gamma, the conservation law array.

    	Each row represents a single conservation law where the column indicate the participating molecular species. The number of rows is therefore equal to the number of conservation laws.
    	In this case the Gamma Matrix is recalculated for the given stoichiometry matrix. amma is calculated based on R = GaussJordan ( [ stoichiometry  I ] ), where R has the form

    	R = [ R11 R12
    			0  GAMMA ]

    	The RowLabels should be an increasing number, to enumerate the conservation law, the column label will be the same label as the stoichiometry matrix.
    	"""
    	import numpy as np

    	if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    		oMatrix = np.array(oMatrix)
    		if oMatrix.ndim == 2:
    			rows = len(oMatrix)
    			cols = len(oMatrix[0])
    			m = DoubleMatrix(rows,cols)
    			for i in range(rows):
    				for j in range (cols):
    					m.set (i, j, oMatrix[i][j])
    			return self._my_getGammaMatrixGJ(m).toNumpy()
    		else:
    			raise ValueError("Expecting 2 dimensional list or numpy array")
    	else:
    		raise ValueError("Expecting list or numpy array")


    def getK0Matrix(self):
    	"""
    	LibStructural.getK0Matrix(self)

    	:returns: the K0 Matrix.
    	K0 is defined such that K0 = -(NIC)\ :sup:`-1`\ * NDC, or equivalently, [NDC NIC][I K0]' = 0 where [NDC NIC] = Nr
    	"""
    	return self._my_getK0Matrix().toNumpy()

    def getKMatrix(self):
    	"""
    	LibStructural.getKMatrix(self)
    	:returns: the K matrix (right nullspace of Nr)
    	The K matrix has the structure, [I K0]'
    	"""
    	return self._my_getKMatrix().toNumpy()

    def getL0Matrix(self):
    	"""
    	LibStructural.getL0Matrix(self)

    	:returns: the L0 Matrix.

    	L0 is defined such that  L0*Nr = N0. L0 forms part of the link matrix, L.  N0 is the set of linear dependent rows from the lower portion of the reordered stoichiometry matrix.

    	"""
    	return self._my_getL0Matrix().toNumpy()

    def getLinkMatrix(self):
    	"""
    	LibStructural.getLinkMatrix(self)
    	:returns: L, the Link Matrix, left nullspace (aka nullspace of the transpose Nr).

    	L will have the structure, [I L0]', such that L*Nr = N
    	"""
    	return self.getLinkMatrix().toNumpy()

    def getN0Matrix(self):
    	"""
    	LibStructural.getN0Matrix(self)
    	:returns: the N0 Matrix.
    	The N0 matrix is the set of linearly dependent rows of N where L0 Nr = N0.
    	"""
    	return self._my_getN0Matrix().toNumpy()

    def getNDCMatrix(self):
    	"""
    	LibStructural.getNDCMatrix(self)
    	:returns: the NDC Matrix (the set of linearly dependent columns of Nr).

    	"""
    	return self._my_getNDCMatrix().toNumpy()

    def getNICMatrix(self):
    	"""
    	LibStructural.getNICMatrix(self)
    	:returns: the NIC Matrix (the set of linearly independent columns of Nr)
    	"""
    	return self._my_getNICMatrix().toNumpy()

    def getNrMatrix(self):
    	"""
    	LibStructural.getNrMatrix(self)

    	:returns: the Nr Matrix.

    	The rows of the Nr matrix will be linearly independent.
    	"""
    	return self._my_getNrMatrix().toNumpy()

    def getReorderedStoichiometryMatrix(self):
    	"""
    	LibStructural.getReorderedStoichiometryMatrix(self)

    	:returns: the reordered stoichiometry matrix (row reordered stoichiometry matrix, columns are not reordered!)

    	"""
    	return self._my_getReorderedStoichiometryMatrix().toNumpy()

    def loadStoichiometryMatrix(self, data):
    		"""
    		LibStructural.loadStoichiometryMatrix(self, Matrix)

    		:param: 2D array stoichiometry matrix

    		Loads a stoichiometry matrix into the library.
    		To analyze the stoichiometry call one of the following:

    		| ``LibStructural.analyzeWithQR``,
    		| ``LibStructural.analyzeWithLU``,
    		| ``LibStructural.analyzeWithLUandRunTests``,
    		| ``LibStructural.analyzeWithFullyPivotedLU``,
    		| ``LibStructural.analyzeWithFullyPivotedLUwithTests``,

    		Remarks: if matrix labels are needed it is recommended to call LibStructural.loadSpecies
    		and ``LibStructural.loadReactionNames``after a call to this method.

    		"""
    		import numpy as np

    		if (type(data) is list or type(data) is np.ndarray):
    			data = np.array(data)
    			if data.ndim == 2:
    				rows = len(data)
    				cols = len(data[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, data[i][j])
    				return self._my_loadStoichiometryMatrix (m)
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
    			raise ValueError("Expecting list or numpy array")

    def rref(self, data, tolerance=1e-6):
    		"""
    		LibStructural.rref(self, matrix, tol)

         Computes the reduced row echelon of the given matrix. Tolerance is set to indicate the smallest number consider to be zero.

    		:param: a matrix (numpy)
    		:param: Optional: tolerance (double), default is 1E-6
    		:returns: reduced row echelon form of the matrix
    		"""
    		import numpy as np

    		if (type(data) is list or type(data) is np.ndarray):
    			data = np.array(data)
    			if data.ndim == 2:
    				rows = len(data)
    				cols = len(data[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, data[i][j])
    				return self._my_rref (m, tolerance).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def rref_FB(self, data, tolerance=1e-6):
    		"""
    		LibStructural.getEigenValues(self, matrix)

    		:param: Matrix to find the refuced row echelon for.
    		:returns: the reduce row echelon.
    		"""

    		import numpy as np

    		if (type(data) is list or type(data) is np.ndarray):
    			data = np.array(data)
    			if data.ndim == 2:
    				rows = len(data)
    				cols = len(data[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, data[i][j])
    				return self._my_rref_FB (m, tolerance).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getEigenValues (self, oMatrix):
    		"""
    		LibStructural.getEigenValues(self, matrix)

    		:param: Matrix to find the eigenvalues for.
    		:returns: an array, first column are the real values and second column are imaginary values
    		"""

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getEigenValues(m).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getEigenVectors (self, oMatrix):
    		"""
    		LibStructural.getEigenVectors(self, matrix)

    		:param: Matrix to find the eigenvectors for
    		:returns: an array where each columns is an eigenvector
    		"""

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getEigenVectors(m).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getConditionNumber (self, oMatrix):
    		'''
    		LibStructural.getConditionNumber(self, matrix)

    		:param: Takes a matrix (numpy) as an argument. Find the condition number of the matrix.
    		:returns: the condition number
    		'''
    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getConditionNumber(m)
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getRConditionNumber (self, oMatrix):
    		'''
    		LibStructural.getRConditionNumber(self, matrix)

    		:param: Takes a matrix (numpy) as an argument. Find the condition number of the matrix.
    		:returns: the condition number
    		'''

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self.getRCond(m)
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getLeftNullSpace (self, oMatrix):
    		"""
    		LibStructural.getConditionNumber(self, matrix)

    		:param: Matrix to find the left nullspace of.
    		:returns: the Left Nullspace of the matrix argument.

    		"""

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getLeftNullSpace(m).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getRightNullSpace (self, oMatrix):
    		"""
    		LibStructural.getRightNullSpace(self, matrix)

    		:param: Matrix to find the right nullspace of.
    		:returns: the Right Nullspace of the matric argument.
    		"""

    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getRightNullSpace(m).toNumpy()
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def getRank (self, oMatrix):
    		"""
    		LibStructural.getRank(self, matrix)

    		:param: Matrix to find the rank of.
    		:returns: the rank as an integer.
    		"""
    		import numpy as np

    		if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
    			oMatrix = np.array(oMatrix)
    			if oMatrix.ndim == 2:
    				rows = len(oMatrix)
    				cols = len(oMatrix[0])
    				m = DoubleMatrix(rows,cols)
    				for i in range(rows):
    					for j in range (cols):
    						m.set (i, j, oMatrix[i][j])
    				return self._my_getRank(m)
    			else:
    				raise ValueError("Expecting 2 dimensional list or numpy array")
    		else:
     		        raise ValueError("Expecting list or numpy array")

    def test (self):
    	import pkg_resources

    	print('****** Testing model 1... ******\n')

    	model_path = pkg_resources.resource_filename('structural','test_models/BMID000000101155.xml')

    	print(self.loadSBMLFromFile(model_path))
    	print('\nValidating structural matrices...\n')
    	print(self.getTestDetails())
    	print(self.validateStructuralMatrices())


    __swig_destroy__ = _structural.delete_LibStructural
    __del__ = lambda self: None
LibStructural_swigregister = _structural.LibStructural_swigregister
LibStructural_swigregister(LibStructural)

def LibStructural_getInstance():
    """
    LibStructural_getInstance() -> LibStructural


    LibStructural.getInstance(self)

    static method to get an instance of LibStructural (allows use as singleton)

     import structural 
     ls = structural.LibStructural.getInstance()

    """
    return _structural.LibStructural_getInstance()

class complexArray(_object):
    """Proxy of C++ complexArray class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, complexArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, complexArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """__init__(complexArray self, size_t nelements) -> complexArray"""
        this = _structural.new_complexArray(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _structural.delete_complexArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        """__getitem__(complexArray self, size_t index) -> LIB_LA::Complex"""
        return _structural.complexArray___getitem__(self, index)


    def __setitem__(self, index, value):
        """__setitem__(complexArray self, size_t index, LIB_LA::Complex value)"""
        return _structural.complexArray___setitem__(self, index, value)


    def cast(self):
        """cast(complexArray self) -> LIB_LA::Complex *"""
        return _structural.complexArray_cast(self)


    def frompointer(t):
        """frompointer(LIB_LA::Complex * t) -> complexArray"""
        return _structural.complexArray_frompointer(t)

    frompointer = staticmethod(frompointer)
complexArray_swigregister = _structural.complexArray_swigregister
complexArray_swigregister(complexArray)

def complexArray_frompointer(t):
    """complexArray_frompointer(LIB_LA::Complex * t) -> complexArray"""
    return _structural.complexArray_frompointer(t)

class doubleArray(_object):
    """Proxy of C++ doubleArray class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """__init__(doubleArray self, size_t nelements) -> doubleArray"""
        this = _structural.new_doubleArray(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _structural.delete_doubleArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        """__getitem__(doubleArray self, size_t index) -> double"""
        return _structural.doubleArray___getitem__(self, index)


    def __setitem__(self, index, value):
        """__setitem__(doubleArray self, size_t index, double value)"""
        return _structural.doubleArray___setitem__(self, index, value)


    def cast(self):
        """cast(doubleArray self) -> double *"""
        return _structural.doubleArray_cast(self)


    def frompointer(t):
        """frompointer(double * t) -> doubleArray"""
        return _structural.doubleArray_frompointer(t)

    frompointer = staticmethod(frompointer)
doubleArray_swigregister = _structural.doubleArray_swigregister
doubleArray_swigregister(doubleArray)

def doubleArray_frompointer(t):
    """doubleArray_frompointer(double * t) -> doubleArray"""
    return _structural.doubleArray_frompointer(t)

class intArray(_object):
    """Proxy of C++ intArray class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """__init__(intArray self, size_t nelements) -> intArray"""
        this = _structural.new_intArray(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _structural.delete_intArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        """__getitem__(intArray self, size_t index) -> int"""
        return _structural.intArray___getitem__(self, index)


    def __setitem__(self, index, value):
        """__setitem__(intArray self, size_t index, int value)"""
        return _structural.intArray___setitem__(self, index, value)


    def cast(self):
        """cast(intArray self) -> int *"""
        return _structural.intArray_cast(self)


    def frompointer(t):
        """frompointer(int * t) -> intArray"""
        return _structural.intArray_frompointer(t)

    frompointer = staticmethod(frompointer)
intArray_swigregister = _structural.intArray_swigregister
intArray_swigregister(intArray)

def intArray_frompointer(t):
    """intArray_frompointer(int * t) -> intArray"""
    return _structural.intArray_frompointer(t)

class DoubleMatrix(_object):
    """Proxy of C++ LIB_LA::Matrix<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LIB_LA::Matrix<(double)> self, unsigned int rows=0, unsigned int cols=0) -> DoubleMatrix
        __init__(LIB_LA::Matrix<(double)> self, unsigned int rows=0) -> DoubleMatrix
        __init__(LIB_LA::Matrix<(double)> self) -> DoubleMatrix
        __init__(LIB_LA::Matrix<(double)> self, DoubleMatrix src) -> DoubleMatrix
        __init__(LIB_LA::Matrix<(double)> self, double *& oRawData, int nRows, int nCols, bool transpose=True) -> DoubleMatrix
        __init__(LIB_LA::Matrix<(double)> self, double *& oRawData, int nRows, int nCols) -> DoubleMatrix
        __init__(LIB_LA::Matrix<(double)> self, double **& oRawData, int nRows, int nCols) -> DoubleMatrix
        __init__(LIB_LA::Matrix<(double)> self, double const ** oRawData, int nRows, int nCols) -> DoubleMatrix
        """
        this = _structural.new_DoubleMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getArray(self):
        """getArray(DoubleMatrix self) -> double *"""
        return _structural.DoubleMatrix_getArray(self)


    def getCopy(self, transpose=False):
        """
        getCopy(DoubleMatrix self, bool transpose=False) -> double
        getCopy(DoubleMatrix self) -> double *
        """
        return _structural.DoubleMatrix_getCopy(self, transpose)


    def initializeFrom2DMatrix(self, oRawData, nRows, nCols):
        """initializeFrom2DMatrix(DoubleMatrix self, double **& oRawData, int nRows, int nCols)"""
        return _structural.DoubleMatrix_initializeFrom2DMatrix(self, oRawData, nRows, nCols)


    def initializeFromConst2DMatrix(self, oRawData, nRows, nCols):
        """initializeFromConst2DMatrix(DoubleMatrix self, double const ** oRawData, int nRows, int nCols)"""
        return _structural.DoubleMatrix_initializeFromConst2DMatrix(self, oRawData, nRows, nCols)

    __swig_destroy__ = _structural.delete_DoubleMatrix
    __del__ = lambda self: None

    def get2DMatrix(self, nRows, nCols):
        """get2DMatrix(DoubleMatrix self, int & nRows, int & nCols) -> double **"""
        return _structural.DoubleMatrix_get2DMatrix(self, nRows, nCols)


    def swapRows(self, row1, row2):
        """swapRows(DoubleMatrix self, unsigned int row1, unsigned int row2)"""
        return _structural.DoubleMatrix_swapRows(self, row1, row2)


    def swapCols(self, col1, col2):
        """swapCols(DoubleMatrix self, unsigned int col1, unsigned int col2)"""
        return _structural.DoubleMatrix_swapCols(self, col1, col2)


    def resize(self, rows, cols):
        """resize(DoubleMatrix self, unsigned int rows, unsigned int cols)"""
        return _structural.DoubleMatrix_resize(self, rows, cols)


    def getTranspose(self):
        """getTranspose(DoubleMatrix self) -> DoubleMatrix"""
        return _structural.DoubleMatrix_getTranspose(self)


    def size(self):
        """size(DoubleMatrix self) -> unsigned int"""
        return _structural.DoubleMatrix_size(self)


    def numRows(self):
        """numRows(DoubleMatrix self) -> unsigned int"""
        return _structural.DoubleMatrix_numRows(self)


    def numCols(self):
        """numCols(DoubleMatrix self) -> unsigned int"""
        return _structural.DoubleMatrix_numCols(self)


    def __call__(self, *args):
        """
        __call__(DoubleMatrix self, unsigned int const & row, unsigned int const & col) -> LIB_LA::Matrix< double >::_ElementType
        __call__(DoubleMatrix self, unsigned int const & row, unsigned int const & col) -> LIB_LA::Matrix< double >::_ElementType const &
        """
        return _structural.DoubleMatrix___call__(self, *args)


    def get(self, row, col):
        """get(DoubleMatrix self, unsigned int const row, unsigned int const col) -> double"""
        return _structural.DoubleMatrix_get(self, row, col)


    def set(self, row, col, value):
        """set(DoubleMatrix self, unsigned int const row, unsigned int const col, double value)"""
        return _structural.DoubleMatrix_set(self, row, col, value)


    def toNumpy(self):
    		import numpy as np
    		result = np.zeros((self.numRows(), self.numCols()))
    		for i in range(self.numRows()):
    				for j in range(self.numCols()):
    						result[i,j] = self.get(i,j)
    		return result
    def __repr__(self):
    		return self.toNumpy().__repr__()

DoubleMatrix_swigregister = _structural.DoubleMatrix_swigregister
DoubleMatrix_swigregister(DoubleMatrix)

class IntMatrix(_object):
    """Proxy of C++ LIB_LA::Matrix<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LIB_LA::Matrix<(int)> self, unsigned int rows=0, unsigned int cols=0) -> IntMatrix
        __init__(LIB_LA::Matrix<(int)> self, unsigned int rows=0) -> IntMatrix
        __init__(LIB_LA::Matrix<(int)> self) -> IntMatrix
        __init__(LIB_LA::Matrix<(int)> self, IntMatrix src) -> IntMatrix
        __init__(LIB_LA::Matrix<(int)> self, int *& oRawData, int nRows, int nCols, bool transpose=True) -> IntMatrix
        __init__(LIB_LA::Matrix<(int)> self, int *& oRawData, int nRows, int nCols) -> IntMatrix
        __init__(LIB_LA::Matrix<(int)> self, int **& oRawData, int nRows, int nCols) -> IntMatrix
        __init__(LIB_LA::Matrix<(int)> self, int const ** oRawData, int nRows, int nCols) -> IntMatrix
        """
        this = _structural.new_IntMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getArray(self):
        """getArray(IntMatrix self) -> int *"""
        return _structural.IntMatrix_getArray(self)


    def getCopy(self, transpose=False):
        """
        getCopy(IntMatrix self, bool transpose=False) -> int
        getCopy(IntMatrix self) -> int *
        """
        return _structural.IntMatrix_getCopy(self, transpose)


    def initializeFrom2DMatrix(self, oRawData, nRows, nCols):
        """initializeFrom2DMatrix(IntMatrix self, int **& oRawData, int nRows, int nCols)"""
        return _structural.IntMatrix_initializeFrom2DMatrix(self, oRawData, nRows, nCols)


    def initializeFromConst2DMatrix(self, oRawData, nRows, nCols):
        """initializeFromConst2DMatrix(IntMatrix self, int const ** oRawData, int nRows, int nCols)"""
        return _structural.IntMatrix_initializeFromConst2DMatrix(self, oRawData, nRows, nCols)

    __swig_destroy__ = _structural.delete_IntMatrix
    __del__ = lambda self: None

    def get2DMatrix(self, nRows, nCols):
        """get2DMatrix(IntMatrix self, int & nRows, int & nCols) -> int **"""
        return _structural.IntMatrix_get2DMatrix(self, nRows, nCols)


    def swapRows(self, row1, row2):
        """swapRows(IntMatrix self, unsigned int row1, unsigned int row2)"""
        return _structural.IntMatrix_swapRows(self, row1, row2)


    def swapCols(self, col1, col2):
        """swapCols(IntMatrix self, unsigned int col1, unsigned int col2)"""
        return _structural.IntMatrix_swapCols(self, col1, col2)


    def resize(self, rows, cols):
        """resize(IntMatrix self, unsigned int rows, unsigned int cols)"""
        return _structural.IntMatrix_resize(self, rows, cols)


    def getTranspose(self):
        """getTranspose(IntMatrix self) -> IntMatrix"""
        return _structural.IntMatrix_getTranspose(self)


    def size(self):
        """size(IntMatrix self) -> unsigned int"""
        return _structural.IntMatrix_size(self)


    def numRows(self):
        """numRows(IntMatrix self) -> unsigned int"""
        return _structural.IntMatrix_numRows(self)


    def numCols(self):
        """numCols(IntMatrix self) -> unsigned int"""
        return _structural.IntMatrix_numCols(self)


    def __call__(self, *args):
        """
        __call__(IntMatrix self, unsigned int const & row, unsigned int const & col) -> LIB_LA::Matrix< int >::_ElementType
        __call__(IntMatrix self, unsigned int const & row, unsigned int const & col) -> LIB_LA::Matrix< int >::_ElementType const &
        """
        return _structural.IntMatrix___call__(self, *args)


    def get(self, row, col):
        """get(IntMatrix self, unsigned int const row, unsigned int const col) -> int"""
        return _structural.IntMatrix_get(self, row, col)


    def set(self, row, col, value):
        """set(IntMatrix self, unsigned int const row, unsigned int const col, int value)"""
        return _structural.IntMatrix_set(self, row, col, value)


    def toNumpy(self):
    		import numpy as np
    		result = np.zeros((self.numRows(), self.numCols()), dtype=np.int)
    		for i in range(self.numRows()):
    				for j in range(self.numCols()):
    						result[i,j] = self.get(i,j)
    		return result
    def __repr__(self):
    		return self.toNumpy().__repr__()

IntMatrix_swigregister = _structural.IntMatrix_swigregister
IntMatrix_swigregister(IntMatrix)

class ComplexMatrix(_object):
    """Proxy of C++ LIB_LA::Matrix<(LIB_LA::Complex)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LIB_LA::Matrix<(LIB_LA::Complex)> self, unsigned int rows=0, unsigned int cols=0) -> ComplexMatrix
        __init__(LIB_LA::Matrix<(LIB_LA::Complex)> self, unsigned int rows=0) -> ComplexMatrix
        __init__(LIB_LA::Matrix<(LIB_LA::Complex)> self) -> ComplexMatrix
        __init__(LIB_LA::Matrix<(LIB_LA::Complex)> self, ComplexMatrix src) -> ComplexMatrix
        __init__(LIB_LA::Matrix<(LIB_LA::Complex)> self, LIB_LA::Complex *& oRawData, int nRows, int nCols, bool transpose=True) -> ComplexMatrix
        __init__(LIB_LA::Matrix<(LIB_LA::Complex)> self, LIB_LA::Complex *& oRawData, int nRows, int nCols) -> ComplexMatrix
        __init__(LIB_LA::Matrix<(LIB_LA::Complex)> self, LIB_LA::Complex **& oRawData, int nRows, int nCols) -> ComplexMatrix
        __init__(LIB_LA::Matrix<(LIB_LA::Complex)> self, LIB_LA::Complex const ** oRawData, int nRows, int nCols) -> ComplexMatrix
        """
        this = _structural.new_ComplexMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getArray(self):
        """getArray(ComplexMatrix self) -> LIB_LA::Complex *"""
        return _structural.ComplexMatrix_getArray(self)


    def getCopy(self, transpose=False):
        """
        getCopy(ComplexMatrix self, bool transpose=False) -> LIB_LA::Complex
        getCopy(ComplexMatrix self) -> LIB_LA::Complex *
        """
        return _structural.ComplexMatrix_getCopy(self, transpose)


    def initializeFrom2DMatrix(self, oRawData, nRows, nCols):
        """initializeFrom2DMatrix(ComplexMatrix self, LIB_LA::Complex **& oRawData, int nRows, int nCols)"""
        return _structural.ComplexMatrix_initializeFrom2DMatrix(self, oRawData, nRows, nCols)


    def initializeFromConst2DMatrix(self, oRawData, nRows, nCols):
        """initializeFromConst2DMatrix(ComplexMatrix self, LIB_LA::Complex const ** oRawData, int nRows, int nCols)"""
        return _structural.ComplexMatrix_initializeFromConst2DMatrix(self, oRawData, nRows, nCols)

    __swig_destroy__ = _structural.delete_ComplexMatrix
    __del__ = lambda self: None

    def get2DMatrix(self, nRows, nCols):
        """get2DMatrix(ComplexMatrix self, int & nRows, int & nCols) -> LIB_LA::Complex **"""
        return _structural.ComplexMatrix_get2DMatrix(self, nRows, nCols)


    def swapRows(self, row1, row2):
        """swapRows(ComplexMatrix self, unsigned int row1, unsigned int row2)"""
        return _structural.ComplexMatrix_swapRows(self, row1, row2)


    def swapCols(self, col1, col2):
        """swapCols(ComplexMatrix self, unsigned int col1, unsigned int col2)"""
        return _structural.ComplexMatrix_swapCols(self, col1, col2)


    def resize(self, rows, cols):
        """resize(ComplexMatrix self, unsigned int rows, unsigned int cols)"""
        return _structural.ComplexMatrix_resize(self, rows, cols)


    def getTranspose(self):
        """getTranspose(ComplexMatrix self) -> ComplexMatrix"""
        return _structural.ComplexMatrix_getTranspose(self)


    def size(self):
        """size(ComplexMatrix self) -> unsigned int"""
        return _structural.ComplexMatrix_size(self)


    def numRows(self):
        """numRows(ComplexMatrix self) -> unsigned int"""
        return _structural.ComplexMatrix_numRows(self)


    def numCols(self):
        """numCols(ComplexMatrix self) -> unsigned int"""
        return _structural.ComplexMatrix_numCols(self)


    def __call__(self, *args):
        """
        __call__(ComplexMatrix self, unsigned int const & row, unsigned int const & col) -> LIB_LA::Matrix< LIB_LA::Complex >::_ElementType
        __call__(ComplexMatrix self, unsigned int const & row, unsigned int const & col) -> LIB_LA::Matrix< LIB_LA::Complex >::_ElementType const &
        """
        return _structural.ComplexMatrix___call__(self, *args)


    def get(self, row, col):
        """get(ComplexMatrix self, unsigned int const row, unsigned int const col) -> LIB_LA::Complex"""
        return _structural.ComplexMatrix_get(self, row, col)


    def set(self, row, col, value):
        """set(ComplexMatrix self, unsigned int const row, unsigned int const col, LIB_LA::Complex value)"""
        return _structural.ComplexMatrix_set(self, row, col, value)


    def toNumpy(self):
    		import numpy as np
    		result = np.zeros((self.numRows(), self.numCols()), dtype=np.complex_)
    		for i in range(self.numRows()):
    				for j in range(self.numCols()):
    						result[i,j] = self.getReal(i,j) + self.getImag(i,j)*1j
    		return result
    def __repr__(self):
    		return self.toNumpy().__repr__()

ComplexMatrix_swigregister = _structural.ComplexMatrix_swigregister
ComplexMatrix_swigregister(ComplexMatrix)

# This file is compatible with both classic and new-style classes.


