# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_structural')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_structural')
    _structural = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_structural', [dirname(__file__)])
        except ImportError:
            import _structural
            return _structural
        try:
            _mod = imp.load_module('_structural', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _structural = swig_import_helper()
    del swig_import_helper
else:
    import _structural
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


NoModelException = _structural.NoModelException

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _structural.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _structural.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _structural.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _structural.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _structural.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _structural.SwigPyIterator_equal(self, x)

    def copy(self):
        return _structural.SwigPyIterator_copy(self)

    def next(self):
        return _structural.SwigPyIterator_next(self)

    def __next__(self):
        return _structural.SwigPyIterator___next__(self)

    def previous(self):
        return _structural.SwigPyIterator_previous(self)

    def advance(self, n):
        return _structural.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _structural.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _structural.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _structural.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _structural.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _structural.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _structural.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _structural.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)
cvar = _structural.cvar


def new_intp():
    return _structural.new_intp()
new_intp = _structural.new_intp

def copy_intp(value):
    return _structural.copy_intp(value)
copy_intp = _structural.copy_intp

def delete_intp(obj):
    return _structural.delete_intp(obj)
delete_intp = _structural.delete_intp

def intp_assign(obj, value):
    return _structural.intp_assign(obj, value)
intp_assign = _structural.intp_assign

def intp_value(obj):
    return _structural.intp_value(obj)
intp_value = _structural.intp_value
class StringDouble(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringDouble, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _structural.new_StringDouble(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _structural.StringDouble_first_set
    __swig_getmethods__["first"] = _structural.StringDouble_first_get
    if _newclass:
        first = _swig_property(_structural.StringDouble_first_get, _structural.StringDouble_first_set)
    __swig_setmethods__["second"] = _structural.StringDouble_second_set
    __swig_getmethods__["second"] = _structural.StringDouble_second_get
    if _newclass:
        second = _swig_property(_structural.StringDouble_second_get, _structural.StringDouble_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _structural.delete_StringDouble
    __del__ = lambda self: None
StringDouble_swigregister = _structural.StringDouble_swigregister
StringDouble_swigregister(StringDouble)

class StrDoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrDoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrDoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _structural.StrDoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _structural.StrDoubleVector___nonzero__(self)

    def __bool__(self):
        return _structural.StrDoubleVector___bool__(self)

    def __len__(self):
        return _structural.StrDoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _structural.StrDoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _structural.StrDoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _structural.StrDoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _structural.StrDoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _structural.StrDoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _structural.StrDoubleVector___setitem__(self, *args)

    def pop(self):
        return _structural.StrDoubleVector_pop(self)

    def append(self, x):
        return _structural.StrDoubleVector_append(self, x)

    def empty(self):
        return _structural.StrDoubleVector_empty(self)

    def size(self):
        return _structural.StrDoubleVector_size(self)

    def swap(self, v):
        return _structural.StrDoubleVector_swap(self, v)

    def begin(self):
        return _structural.StrDoubleVector_begin(self)

    def end(self):
        return _structural.StrDoubleVector_end(self)

    def rbegin(self):
        return _structural.StrDoubleVector_rbegin(self)

    def rend(self):
        return _structural.StrDoubleVector_rend(self)

    def clear(self):
        return _structural.StrDoubleVector_clear(self)

    def get_allocator(self):
        return _structural.StrDoubleVector_get_allocator(self)

    def pop_back(self):
        return _structural.StrDoubleVector_pop_back(self)

    def erase(self, *args):
        return _structural.StrDoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _structural.new_StrDoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _structural.StrDoubleVector_push_back(self, x)

    def front(self):
        return _structural.StrDoubleVector_front(self)

    def back(self):
        return _structural.StrDoubleVector_back(self)

    def assign(self, n, x):
        return _structural.StrDoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _structural.StrDoubleVector_resize(self, *args)

    def insert(self, *args):
        return _structural.StrDoubleVector_insert(self, *args)

    def reserve(self, n):
        return _structural.StrDoubleVector_reserve(self, n)

    def capacity(self):
        return _structural.StrDoubleVector_capacity(self)
    __swig_destroy__ = _structural.delete_StrDoubleVector
    __del__ = lambda self: None
StrDoubleVector_swigregister = _structural.StrDoubleVector_swigregister
StrDoubleVector_swigregister(StrDoubleVector)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _structural.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _structural.StringVector___nonzero__(self)

    def __bool__(self):
        return _structural.StringVector___bool__(self)

    def __len__(self):
        return _structural.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _structural.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _structural.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _structural.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _structural.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _structural.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _structural.StringVector___setitem__(self, *args)

    def pop(self):
        return _structural.StringVector_pop(self)

    def append(self, x):
        return _structural.StringVector_append(self, x)

    def empty(self):
        return _structural.StringVector_empty(self)

    def size(self):
        return _structural.StringVector_size(self)

    def swap(self, v):
        return _structural.StringVector_swap(self, v)

    def begin(self):
        return _structural.StringVector_begin(self)

    def end(self):
        return _structural.StringVector_end(self)

    def rbegin(self):
        return _structural.StringVector_rbegin(self)

    def rend(self):
        return _structural.StringVector_rend(self)

    def clear(self):
        return _structural.StringVector_clear(self)

    def get_allocator(self):
        return _structural.StringVector_get_allocator(self)

    def pop_back(self):
        return _structural.StringVector_pop_back(self)

    def erase(self, *args):
        return _structural.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _structural.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _structural.StringVector_push_back(self, x)

    def front(self):
        return _structural.StringVector_front(self)

    def back(self):
        return _structural.StringVector_back(self)

    def assign(self, n, x):
        return _structural.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _structural.StringVector_resize(self, *args)

    def insert(self, *args):
        return _structural.StringVector_insert(self, *args)

    def reserve(self, n):
        return _structural.StringVector_reserve(self, n)

    def capacity(self):
        return _structural.StringVector_capacity(self)
    __swig_destroy__ = _structural.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _structural.StringVector_swigregister
StringVector_swigregister(StringVector)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _structural.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _structural.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _structural.DoubleVector___bool__(self)

    def __len__(self):
        return _structural.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _structural.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _structural.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _structural.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _structural.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _structural.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _structural.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _structural.DoubleVector_pop(self)

    def append(self, x):
        return _structural.DoubleVector_append(self, x)

    def empty(self):
        return _structural.DoubleVector_empty(self)

    def size(self):
        return _structural.DoubleVector_size(self)

    def swap(self, v):
        return _structural.DoubleVector_swap(self, v)

    def begin(self):
        return _structural.DoubleVector_begin(self)

    def end(self):
        return _structural.DoubleVector_end(self)

    def rbegin(self):
        return _structural.DoubleVector_rbegin(self)

    def rend(self):
        return _structural.DoubleVector_rend(self)

    def clear(self):
        return _structural.DoubleVector_clear(self)

    def get_allocator(self):
        return _structural.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _structural.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _structural.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _structural.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _structural.DoubleVector_push_back(self, x)

    def front(self):
        return _structural.DoubleVector_front(self)

    def back(self):
        return _structural.DoubleVector_back(self)

    def assign(self, n, x):
        return _structural.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _structural.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _structural.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _structural.DoubleVector_reserve(self, n)

    def capacity(self):
        return _structural.DoubleVector_capacity(self)
    __swig_destroy__ = _structural.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _structural.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class StringVectorx2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVectorx2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVectorx2, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _structural.new_StringVectorx2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _structural.StringVectorx2_first_set
    __swig_getmethods__["first"] = _structural.StringVectorx2_first_get
    if _newclass:
        first = _swig_property(_structural.StringVectorx2_first_get, _structural.StringVectorx2_first_set)
    __swig_setmethods__["second"] = _structural.StringVectorx2_second_set
    __swig_getmethods__["second"] = _structural.StringVectorx2_second_get
    if _newclass:
        second = _swig_property(_structural.StringVectorx2_second_get, _structural.StringVectorx2_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _structural.delete_StringVectorx2
    __del__ = lambda self: None
StringVectorx2_swigregister = _structural.StringVectorx2_swigregister
StringVectorx2_swigregister(StringVectorx2)

class DoubleMatrixStringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleMatrixStringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleMatrixStringVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _structural.new_DoubleMatrixStringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _structural.DoubleMatrixStringVector_first_set
    __swig_getmethods__["first"] = _structural.DoubleMatrixStringVector_first_get
    if _newclass:
        first = _swig_property(_structural.DoubleMatrixStringVector_first_get, _structural.DoubleMatrixStringVector_first_set)
    __swig_setmethods__["second"] = _structural.DoubleMatrixStringVector_second_set
    __swig_getmethods__["second"] = _structural.DoubleMatrixStringVector_second_get
    if _newclass:
        second = _swig_property(_structural.DoubleMatrixStringVector_second_get, _structural.DoubleMatrixStringVector_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _structural.delete_DoubleMatrixStringVector
    __del__ = lambda self: None
DoubleMatrixStringVector_swigregister = _structural.DoubleMatrixStringVector_swigregister
DoubleMatrixStringVector_swigregister(DoubleMatrixStringVector)


def getVersion():
    return _structural.getVersion()
getVersion = _structural.getVersion
SUCCESS = _structural.SUCCESS
UNKNOWN_ERROR = _structural.UNKNOWN_ERROR
NO_MODEL_LOADED = _structural.NO_MODEL_LOADED
APPLICATION_EXCEPTION = _structural.APPLICATION_EXCEPTION
EMPTY_MATRIX = _structural.EMPTY_MATRIX
class LibStructural(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LibStructural, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LibStructural, name)
    __repr__ = _swig_repr

    def isModelLoaded(self):
        return _structural.LibStructural_isModelLoaded(self)

    def _my_loadStoichiometryMatrix(self, oMatrix):
        return _structural.LibStructural__my_loadStoichiometryMatrix(self, oMatrix)

    def _my_rref(self, oMatrix, tolerance):
        return _structural.LibStructural__my_rref(self, oMatrix, tolerance)

    def _my_rref_FB(self, oMatrix, tolerance):
        return _structural.LibStructural__my_rref_FB(self, oMatrix, tolerance)

    def loadSBMLFromString(self, sSBML):
        """

        LibStructural.loadSBMLFromString(self, SBMLstring)

        :param: SBML string to load
        :returns: Information about the loaded model

        Loads SBML model from a string variable.


        """
        return _structural.LibStructural_loadSBMLFromString(self, sSBML)


    def loadSBMLFromFile(self, sFileName):
        """

        LibStructural.loadSBMLFromFile(self, SBMLfile)

        :param: An SBML file name to load
        :returns: Information about the loaded model

        Loads SBML model from the specified file.


        """
        return _structural.LibStructural_loadSBMLFromFile(self, sFileName)


    def loadSBMLwithTests(self, sSBML):
        """

        LibStructural.loadSBMLwithTests(self, *args)

        :param: A file name to an SBML model to load
        :returns: Information about the loaded model and results of the internal test suite

        Loads an SBML model into the library and carries out tests using the internal test suite.


        """
        return _structural.LibStructural_loadSBMLwithTests(self, sSBML)


    def analyzeWithQR(self):
        """

        LibStructural.analyzeWithQR(self)

        Uses QR factorization for structural analysis. This method performs the actual analysis of the stoichiometry matrix loaded
        either via

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``.

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLU``,
          ``RunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU``,
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``


        Remarks: This is the prefered method for structural analysis.

        :returns: A string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithQR(self)


    def analyzeWithLU(self):
        """

        LibStructural.analyzeWithLU(self)
        Uses LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix (loaded either
        via

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``.

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLUandRunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        :returns: A string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithLU(self)


    def analyzeWithLUandRunTests(self):
        """

        LibStructural.analyzeWithLUandRunTests(self)
        Uses LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix loaded either
        via

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``.

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLUandRunTests``,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests''

        This method additionally performs the integrated test suite and returns	those results.

        :returns: A string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithLUandRunTests(self)


    def analyzeWithFullyPivotedLU(self):
        """

        LibStructural.analyzeWithFullyPivotedLU(self)
        Uses fully pivoted LU Decomposition for Conservation analysis.This method performs the actual analysis of the stoichiometry matrix loaded either
        via

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``.

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``
        | ``LibStructural.analyzeWithLU``
        | ``LibStructural.analyzeWithLUandRunTests``
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        :returns: A string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithFullyPivotedLU(self)


    def analyzeWithFullyPivotedLUwithTests(self):
        """

        LibStructural.analyzeWithFullyPivotedLUwithTests(self)
        Uses fully pivoted LU Decomposition for Conservation analysis. This method performs the actual analysis of the stoichiometry matrix loaded
        either via

        ``LibStructural.loadStoichiometryMatrix`` or ``LibStructural.loadSBMLFromString``.

        Only after one of the analysis methods below has been called are the structural matrices (L0, K0...) available.

        | ``LibStructural.analyzeWithQR``,
        | ``LibStructural.analyzeWithLU``,
        | ``LibStructural.analyzeWithLU``andRunTests,
        | ``LibStructural.analyzeWithFullyPivotedLU`` or
        | ``LibStructural.analyzeWithFullyPivotedLUwithTests``

        This method additionally performs the integrated test suite and returns	those results.

        :returns: A string with information about the analysis process


        """
        return _structural.LibStructural_analyzeWithFullyPivotedLUwithTests(self)


    def getSummary(self):
        """

        LibStructural.getSummary(self, *args)

        :returns: Returns the summary string of the last analysis.


        """
        return _structural.LibStructural_getSummary(self)


    def _my_getL0Matrix(self):
        return _structural.LibStructural__my_getL0Matrix(self)

    def _my_getNrMatrix(self):
        return _structural.LibStructural__my_getNrMatrix(self)

    def _my_getFullyReorderedNrMatrix(self):
        return _structural.LibStructural__my_getFullyReorderedNrMatrix(self)

    def _my_getFullyReorderedN0StoichiometryMatrix(self):
        return _structural.LibStructural__my_getFullyReorderedN0StoichiometryMatrix(self)

    def _my_getColumnReorderedNrMatrix(self):
        return _structural.LibStructural__my_getColumnReorderedNrMatrix(self)

    def _my_getNICMatrix(self):
        return _structural.LibStructural__my_getNICMatrix(self)

    def _my_getNDCMatrix(self):
        return _structural.LibStructural__my_getNDCMatrix(self)

    def _my_getN0Matrix(self):
        return _structural.LibStructural__my_getN0Matrix(self)

    def _my_getLinkMatrix(self):
        return _structural.LibStructural__my_getLinkMatrix(self)

    def _my_getK0Matrix(self):
        return _structural.LibStructural__my_getK0Matrix(self)

    def _my_getKMatrix(self):
        return _structural.LibStructural__my_getKMatrix(self)

    def _my_getGammaMatrix(self):
        return _structural.LibStructural__my_getGammaMatrix(self)

    def _my_getGammaMatrixGJ(self, stoichiometry):
        return _structural.LibStructural__my_getGammaMatrixGJ(self, stoichiometry)

    def _my_getStoichiometryMatrix(self):
        return _structural.LibStructural__my_getStoichiometryMatrix(self)

    def _my_getStoichiometryMatrixBoundary(self):
        return _structural.LibStructural__my_getStoichiometryMatrixBoundary(self)

    def _my_getReorderedStoichiometryMatrix(self):
        return _structural.LibStructural__my_getReorderedStoichiometryMatrix(self)

    def _my_getFullyReorderedStoichiometryMatrix(self):
        return _structural.LibStructural__my_getFullyReorderedStoichiometryMatrix(self)

    def getReorderedSpeciesIds(self):
        """

        LibStructural.getReorderedSpeciesIds(self)

        :returns: The reordered list of molecular species (choosing the SBML Id if possible)


        """
        return _structural.LibStructural_getReorderedSpeciesIds(self)


    def getFloatingSpeciesIds(self):
        """

        LibStructural.getFloatingSpeciesIds(self)

        :returns: The unordered list of floating species Ids.


        """
        return _structural.LibStructural_getFloatingSpeciesIds(self)


    def getBoundarySpeciesIds(self):
        return _structural.LibStructural_getBoundarySpeciesIds(self)

    def getIndependentSpeciesIds(self):
        """

        LibStructural.getIndependentSpeciesIds(self)

        :returns: The list of Ids for the independent species.


        """
        return _structural.LibStructural_getIndependentSpeciesIds(self)


    def getDependentSpeciesIds(self):
        """

        LibStructural.getDependentSpeciesIds(self)

        :returns: The list of Ids for the dependent species.


        """
        return _structural.LibStructural_getDependentSpeciesIds(self)


    def getReactionIds(self):
        """

        LibStructural.getReactionIds(self)

        :returns: The list of reaction ids


        """
        return _structural.LibStructural_getReactionIds(self)


    def getIndependentReactionIds(self):
        """

        LibStructural.getIndependentReactionIds(self)

        :returns: The list of Ids for the independent reactions.


        """
        return _structural.LibStructural_getIndependentReactionIds(self)


    def getDependentReactionIds(self):
        """

        LibStructural.getDependentReactionIds(self)

        :returns: The list of Ids for the dependent reactions.


        """
        return _structural.LibStructural_getDependentReactionIds(self)


    def getReorderedReactionIds(self):
        """

        LibStructural.getReorderedReactionIds(self)

        :returns: The reordered Id list of reactions.


        """
        return _structural.LibStructural_getReorderedReactionIds(self)


    def getConservedLaws(self):
        """

        LibStructural.getConservedLaws(self)

        :returns: Algebraic expressions for the conserved cycles. Returns empty if none.


        """
        return _structural.LibStructural_getConservedLaws(self)


    def getConservedSums(self):
        """

        LibStructural.getConservedSums(self)

        :returns: Total mass for each conserved cycle in the model. The sum is based on the current initial conditions.


        """
        return _structural.LibStructural_getConservedSums(self)


    def getInitialConditions(self):
        """

        LibStructural.getInitialConditions(self)

        :returns: Initial Conditions used in the model.


        """
        return _structural.LibStructural_getInitialConditions(self)


    def validateStructuralMatrices(self):
        """

        LibStructural.validateStructuralMatrices(self)

        Validates structural matrices. Calling this method will run the internal test suite against the structural matrices. Those tests include:

        | Test 1 : Gamma*N = 0 (Zero matrix)
        | Test 2 : Rank(N) using SVD (5) is same as m0 (5)
        | Test 3 : Rank(NR) using SVD (5) is same as m0 (5)
        | Test 4 : Rank(NR) using QR (5) is same as m0 (5)
        | Test 5 : L0 obtained with QR matches Q21*inv(Q11)
        | Test 6 : N*K = 0 (Zero matrix)

        :returns: A tuple of strings indicating whether a particular test passed or failed.

        """
        return _structural.LibStructural_validateStructuralMatrices(self)


    def getTestDetails(self):
        """

        LibStructural.getTestDetails(self)

        :returns: Details about the validation tests.


        """
        return _structural.LibStructural_getTestDetails(self)


    def getModelName(self):
        """

        LibStructural.getModelName(self)

        :returns: The name of the model if SBML model has Name-tag, otherwise it returns the SBML id. If only a stoichiometry matrix was loaded 'untitled' will be returned.


        """
        return _structural.LibStructural_getModelName(self)


    def getNumFloatingSpecies(self):
        return _structural.LibStructural_getNumFloatingSpecies(self)

    def getNumBoundarySpecies(self):
        return _structural.LibStructural_getNumBoundarySpecies(self)

    def getNumIndSpecies(self):
        """

        LibStructural.getNumIndSpecies(self)

        :returns: The number of independent species.


        """
        return _structural.LibStructural_getNumIndSpecies(self)


    def getNumDepSpecies(self):
        """

        LibStructural.getNumDepSpecies(self)

        :returns: The number of dependent species.


        """
        return _structural.LibStructural_getNumDepSpecies(self)


    def getNumReactions(self):
        """

        LibStructural.getNumReactions(self)

        :returns: The total number of reactions.


        """
        return _structural.LibStructural_getNumReactions(self)


    def getNumIndReactions(self):
        """

        LibStructural.getNumIndReactions(self)

        :returns: The number of independent reactions


        """
        return _structural.LibStructural_getNumIndReactions(self)


    def getNumDepReactions(self):
        """

        LibStructural.getNumDepReactions(self)

        :returns: The number of dependent reactions


        """
        return _structural.LibStructural_getNumDepReactions(self)


    def getNmatrixSparsity(self):
        """

        LibStructural.getNmatrixSparsity(self)

        :returns: The number of nonzero values in Stoichiometry matrix


        """
        return _structural.LibStructural_getNmatrixSparsity(self)


    def isReactionReversible(self, index):
        """

        LibStructural.isReactionReversible(self, *args)

        :param: Reaction index
        :returns: True if the reaction with given index is reversible
        Checks whether a given reaction is reversible or not.


        """
        return _structural.LibStructural_isReactionReversible(self, index)


    def _my_getElementaryModesInteger(self):
        return _structural.LibStructural__my_getElementaryModesInteger(self)

    def gefm_getErrorString(self):
        return _structural.LibStructural_gefm_getErrorString(self)

    def _my_getgElementaryModes(self, errorCode):
        return _structural.LibStructural__my_getgElementaryModes(self, errorCode)

    def _my_saveElementaryModes(self, errorCode, csv_format):
        return _structural.LibStructural__my_saveElementaryModes(self, errorCode, csv_format)

    def _my_getEigenValues(self, oMatrix):
        return _structural.LibStructural__my_getEigenValues(self, oMatrix)

    def _my_getEigenVectors(self, oMatrix):
        return _structural.LibStructural__my_getEigenVectors(self, oMatrix)

    def _my_getConditionNumber(self, oMatrix):
        return _structural.LibStructural__my_getConditionNumber(self, oMatrix)

    def _my_getLeftNullSpace(self, oMatrix):
        return _structural.LibStructural__my_getLeftNullSpace(self, oMatrix)

    def _my_getRightNullSpace(self, oMatrix):
        return _structural.LibStructural__my_getRightNullSpace(self, oMatrix)

    def _my_getRank(self, *args):
        """

        LibStructural.getRank(self);

        :param: Matrix.

        :returns: The rank of the matrix as an integer


        """
        return _structural.LibStructural__my_getRank(self, *args)


    def _my_getRCond(self, oMatrix):
        """

        LibStructural.getRCond(self, *args)



        """
        return _structural.LibStructural__my_getRCond(self, oMatrix)


    def setTolerance(self, dTolerance):
        """

        LibStructural.setTolerance(self, *args)

        :param: An integer or a float

        Sets user specified tolerance. This function sets the tolerance used by the library to determine what value is considered as zero. Any value with absolute value smaller than this tolerance is considered as zero and will be neglected.


        """
        return _structural.LibStructural_setTolerance(self, dTolerance)


    def getTolerance(self):
        """

        LibStructural.getTolerance(self)

        :returns: The currently used tolerance for deciding whether a small number is considered zero or not.

        This function returns the tolerance currently used by the library to determine what value
        is considered as zero. Any value with absolute value smaller than this tolerance is considered zero
        and will be neglected.


        """
        return _structural.LibStructural_getTolerance(self)


    def __init__(self):
        this = _structural.new_LibStructural()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getInstance():
        """

        LibStructural.getInstance(self)

        static method to get an instance of LibStructural (allows use as singleton)

        .. code:: python

        import structural
        ls = structural.LibStructural.getInstance()

        .. end


        """
        return _structural.LibStructural_getInstance()

    getInstance = staticmethod(getInstance)

    def getColumnReorderedNrMatrixIds(self):
        """

        LibStructural.getColumnReorderedNrMatrixIds(self)

        :returns: The Nr Matrix row and column labels (repartitioned into NIC and NDC).


        """
        return _structural.LibStructural_getColumnReorderedNrMatrixIds(self)


    def loadReactionIds(self, *args):
        return _structural.LibStructural_loadReactionIds(self, *args)

    def loadReactionIdsWithValues(self, *args):
        """


        LibStructural.loadReactionIdsWithValues(self, id_array, value_array)

        :param: A vector  of reaction ids to load
        :param: A vector of reaction rates

        This function should be used whenever labeled matrices are important as these labels will be used in labeling the structural matrices. This function sets the reaction ids. It is also possible to provide reaction rate values. This will be used when calculating the conserved sums.

        Remarks: This method should only be called after ``LibStructural.loadStoichiometryMatrix``. ``LibStructural.analyzeWithQR`` should be called for the function to take effect.


        """
        return _structural.LibStructural_loadReactionIdsWithValues(self, *args)


    def loadSpeciesIdsWithValues(self, *args):
        """

        LibStructural.loadSpeciesIdsWithValues(self, id_array, value_array)

        :param: A vector of species ids to load
        :param: A vector of initial concentrations

        Loads species names and initial values. This function should be used whenever labeled matrices are important as these labels will be used in labeling the structural matrices. This function sets the species ids. It is also possible to provide an initial condition for each of the species. This will be used when calculating the conserved sums.

        Remarks: This method should only be called after ``LibStructural.loadStoichiometryMatrix``. ``LibStructural.analyzeWithQR`` should be called for the function to take effect.


        """
        return _structural.LibStructural_loadSpeciesIdsWithValues(self, *args)


    def getGammaMatrixIds(self):
        """

        LibStructural.getGammaMatrixIds(self)

        :returns: The row and column labels for Gamma, the conservation law array.

        """
        return _structural.LibStructural_getGammaMatrixIds(self)


    def getK0MatrixIds(self):
        """

        LibStructural.getK0MatrixIds(self)

        :returns: The K0 Matrix row and column labels.


        """
        return _structural.LibStructural_getK0MatrixIds(self)


    def getKMatrixIds(self):
        """

        LibStructural.getKMatrixIds(self)

        :returns: the K matrix row and column labels.


        """
        return _structural.LibStructural_getKMatrixIds(self)


    def getL0MatrixIds(self):
        """

        LibStructural.getL0MatrixIds(self)

        :returns: The L0 Matrix row and column labels.


        """
        return _structural.LibStructural_getL0MatrixIds(self)


    def getLinkMatrixIds(self):
        """

        LibStructural.getLinkMatrixIds(self)

        :returns: The row and column labels for the Link Matrix, L


        """
        return _structural.LibStructural_getLinkMatrixIds(self)


    def getN0MatrixIds(self):
        """

        LibStructural.getN0MatrixIds(self)

        :returns: The N0 Matrix row and column labels.


        """
        return _structural.LibStructural_getN0MatrixIds(self)


    def getNDCMatrixIds(self):
        """

        LibStructural.getNDCMatrixIds(self)

        :returns: The NDC Matrix row and column labels.


        """
        return _structural.LibStructural_getNDCMatrixIds(self)


    def getNICMatrixIds(self):
        """

        LibStructural.getNICMatrixIds(self)

        :returns: The NIC Matrix row and column labels.


        """
        return _structural.LibStructural_getNICMatrixIds(self)


    def getNrMatrixIds(self):
        """

        LibStructural.getNrMatrixIds(self)

        :returns: The Nr Matrix row and column labels.


        """
        return _structural.LibStructural_getNrMatrixIds(self)


    def getStoichiometryMatrixIds(self):
        """

        LibStructural.getStoichiometryMatrixIds(self)

        :returns: The row and column labels for the original and unaltered stoichiometry matrix.


        """
        return _structural.LibStructural_getStoichiometryMatrixIds(self)


    def getFullyReorderedStoichiometryMatrixIds(self):
        """

        LibStructural.getFullyReorderedStoichiometryMatrixIds(self)

        :returns: The row and column labels for the reordered stoichiometry matrix (row reordered stoichiometry matrix)


        """
        return _structural.LibStructural_getFullyReorderedStoichiometryMatrixIds(self)


    def getReorderedStoichiometryMatrixIds(self):
        """

        LibStructural.getReorderedStoichiometryMatrixIds(self)

        :returns: The row and column labels for the reordered stoichiometry matrix (row reordered stoichiometry matrix)


        """
        return _structural.LibStructural_getReorderedStoichiometryMatrixIds(self)


    global MetaToolexitCodeDict
    global gEFMexitCodeDict
    MetaToolexitCodeDict = {
      -1 : "MetaTool Error: Not enough memory: Programm prematurely finished",
    -2 : "MetaTool Error: amount for allocation is zero : Programm prematurely finished",
    -3 : "MetaTool Error: A metabolite could not be found in the stoichiometric equations! Program prematurely terminated",
    -4 : "MetaTool Error: Enzyme name could not be found in the stoichiometric equations! Program prematurely finished",
    -5 : "MetaTool Error: File error",
    -6 : "MetaTool Error: Enlarge the array size of the struct enc ri.Program prematurely finished",
    -7 : "MetaTool Error: An enzyme reaction is defined more than once. Please delete the extra defined reaction in the input file. Program prematurly finished.",
    -8 : "MetaTool Error: The system comprises only external metabolites.",
    -9 : "MetaTool Error: File error",
    -10 : "MetaTool Error: The input file contains interlocking commentaries. (To many closing marks)",
    -11 : "MetaTool Error: The input file contains interlocking commentaries.",
    -12 : "MetaTool Error: ERROR IN FUNCTION CUTCOL",
    -13 : "MetaTool Error: An intermediate result exceeds the allowed integer range: Program prematurely finished.",
    -14 : "MetaTool Error: The name of input file is the same as the name of the output file: Program prematurely finished.",
    -15 : "MetaTool Error: An enzyme is delared twice: Program prematurely finished.",
    -16 : "MetaTool Error: There are metabolites in the stoichiometric equations and are declared as -METINT or -METEXT: Program prematurely terminated.",
    -17 : "MetaTool Error: File error",
    }

    gEFMexitCodeDict = {
    -2 : "gEFM Error: Error allocating memory for reversible tree indices",
    -3 : "gEFM Error: Error loading network file",
    -4 : "gEFM Error: Maximum number of reactions supported is 448",
    }

    def getStoichiometryMatrix(self):
      """
      LibStructural.getStoichiometryMatrix(self)
      :returns: Unaltered stoichiometry matrix.
      """
      return self._my_getStoichiometryMatrix().toNumpy();

    def getStoichiometryMatrixBoundary(self):
      """
      LibStructural.getStoichiometryMatrixBoundary(self)
      :returns: Unaltered stoichiometry matrix with boundary species included at the end.
      """
      return self._my_getStoichiometryMatrixBoundary().toNumpy();

    def getColumnReorderedNrMatrix(self):
        """
        LibStructural.getColumnReorderedNrMatrix(self)
        :returns: The Nr Matrix repartitioned into NIC (independent columns) and NDC (dependent columns). The Nr matrix contains the independent rows of the stoichiometry matrix
        """
        return self._my_getColumnReorderedNrMatrix().toNumpy()

    def getFullyReorderedN0StoichiometryMatrix(self):
        """
        LibStructural.getFullyReorderedN0StoichiometryMatrix(self)

        Computes the N0 matrix if possible. The N0 matrix will contain all the dependent rows of the stoichiometry matrix.

        :returns: The N0 Matrix.

        """
        return self._my_getFullyReorderedN0StoichiometryMatrix().toNumpy()

    def getFullyReorderedNrMatrix(self):
        """
        LibStructural.getFullyReorderedNrMatrix(self)

        The Nr matrix contains all the linearly independent rows of the stoichiometry matrix.

        :returns: The Nr Matrix.
        """
        return self._my_getFullyReorderedNrMatrix().toNumpy()

    def getFullyReorderedStoichiometryMatrix(self):
        """
        LibStructural.getFullyReorderedStoichiometryMatrix(self)
        :returns: The fully reordered stoichiometry matrix. Rows and columns are reordered so all indepedent rows
        of the stoichiometry matrix are brought to the top and left side of the matrix.
        """
        return self._my_getFullyReorderedStoichiometryMatrix().toNumpy()

    def getGammaMatrix(self):
        """
        LibStructural.getGammaMatrix(self)
        :returns: Gamma, the conservation law array.
        Each row represents a single conservation law where the column indicates the participating molecular species.
        The number of rows is therefore equal to the number of conservation laws. Columns are ordered according to the
        rows in the reordered stoichiometry matrix, see ``LibStructural.getReorderedSpeciesId`` and ``LibStructural.getReorderedStoichiometryMatrix``.

        """
        return self._my_getGammaMatrix().toNumpy()

    def getGammaMatrixGJ(self, oMatrix):
        """
        LibStructural.getGammaMatrixGJ(self,matrix)

        :param: The stoichiometry matrix that will be used to calculate gamma matrix.
        :returns: Gamma, the conservation law array.

        Each row represents a single conservation law where the column indicate the participating molecular species. The number of rows is therefore equal to the number of conservation laws. In this case the Gamma Matrix is recalculated for the given stoichiometry matrix. The column label will be the same label as the stoichiometry matrix.
        """
        import numpy as np

        if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
            oMatrix = np.array(oMatrix)
            if oMatrix.ndim == 2:
                rows = len(oMatrix)
                cols = len(oMatrix[0])
                m = DoubleMatrix(rows,cols)
                for i in range(rows):
                    for j in range (cols):
                        m.set (i, j, float(oMatrix[i][j]))
                return self._my_getGammaMatrixGJ(m).toNumpy()
            else:
                raise ValueError("Expecting 2 dimensional list or numpy array")
        else:
            raise ValueError("Expecting list or numpy array")


    def getK0Matrix(self):
        """
        LibStructural.getK0Matrix(self)

        :returns: The K0 Matrix.
        K0 is defined such that K0 = -(NIC)\ :sup:`-1`\ * NDC, or equivalently, [NDC NIC][I K0]' = 0 where [NDC NIC] = Nr
        """
        return self._my_getK0Matrix().toNumpy()

    def getKMatrix(self):
        """
        LibStructural.getKMatrix(self)
        :returns: The K matrix (right nullspace of Nr)
        The K matrix has the structure, [I K0]'
        """
        return self._my_getKMatrix().toNumpy()

    def getL0Matrix(self):
        """
        LibStructural.getL0Matrix(self)

        :returns: The L0 Matrix.

        L0 is defined such that  L0*Nr = N0. L0 forms part of the link matrix, L.  N0 is the set of linear dependent rows from the lower portion of the reordered stoichiometry matrix.

        """
        return self._my_getL0Matrix().toNumpy()

    def getLinkMatrix(self):
        """
        LibStructural.getLinkMatrix(self)
        :returns: L, the Link Matrix, left nullspace (aka nullspace of the transpose Nr).

        L will have the structure, [I L0]', such that L*Nr = N
        """
        return self._my_getLinkMatrix().toNumpy()

    def getN0Matrix(self):
        """
        LibStructural.getN0Matrix(self)
        :returns: The N0 Matrix.
        The N0 matrix is the set of linearly dependent rows of N where L0 Nr = N0.
        """
        return self._my_getN0Matrix().toNumpy()

    def getNDCMatrix(self):
        """
        LibStructural.getNDCMatrix(self)
        :returns: The NDC Matrix (the set of linearly dependent columns of Nr).

        """
        return self._my_getNDCMatrix().toNumpy()

    def getNICMatrix(self):
        """
        LibStructural.getNICMatrix(self)
        :returns: The NIC Matrix (the set of linearly independent columns of Nr)
        """
        return self._my_getNICMatrix().toNumpy()

    def getNrMatrix(self):
        """
        LibStructural.getNrMatrix(self)

        :returns: The Nr Matrix.

        The rows of the Nr matrix will be linearly independent.
        """
        return self._my_getNrMatrix().toNumpy()

    def getReorderedStoichiometryMatrix(self):
        """
        LibStructural.getReorderedStoichiometryMatrix(self)

        :returns: The reordered stoichiometry matrix (row reordered stoichiometry matrix, columns are not reordered!)

        """
        return self._my_getReorderedStoichiometryMatrix().toNumpy()

    def loadStoichiometryMatrix(self, data):
            """
            LibStructural.loadStoichiometryMatrix(self, Matrix)

            :param: 2D array stoichiometry matrix

            Loads a stoichiometry matrix into the library.
            To analyze the stoichiometry call one of the following:

            | ``LibStructural.analyzeWithQR``,
            | ``LibStructural.analyzeWithLU``,
            | ``LibStructural.analyzeWithLUandRunTests``,
            | ``LibStructural.analyzeWithFullyPivotedLU``,
            | ``LibStructural.analyzeWithFullyPivotedLUwithTests``,

            """
            import numpy as np

            if (type(data) is list or type(data) is np.ndarray):
                data = np.array(data)
                if data.ndim == 2:
                    rows = len(data)
                    cols = len(data[0])
                    m = DoubleMatrix(rows,cols)
                    for i in range(rows):
                        for j in range (cols):
                            m.set (i, j, float(data[i][j]))
                    return self._my_loadStoichiometryMatrix (m)
                else:
                    raise ValueError("Expecting 2 dimensional list or numpy array")
            else:
                raise ValueError("Expecting list or numpy array")

    def getElementaryModesInteger (self):
      """
      LibStructural.getElementaryModesInteger(self)

      :returns: An array where each column is an elementary mode
      """
      import numpy as np
      elementaryModes =  self._my_getElementaryModesInteger().toNumpy()
      if np.any(elementaryModes):
        return elementaryModes
      else:
        return np.empty(0)

    def getgElementaryModes (self):
      """
      LibStructural.getgElementaryModes(self)

      :returns: An array where each column is an elementary mode
      """
      import numpy as np
      errorCode = new_intp()
      elementaryModes =  self._my_getgElementaryModes(errorCode).toNumpy()
      if intp_value(errorCode) < 0:
        raise RuntimeError(self.gefm_getErrorString())

      if np.any(elementaryModes):
        return elementaryModes
      else:
        return np.empty(0)

    def saveElementaryModes (self, csv_format=False):
      """
      LibStructural.saveElementaryModes(self, csv_format=False)

      :returns: A directory path for the file generated
      """
      import numpy as np
      errorCode = new_intp()
      outputPath = self._my_saveElementaryModes(errorCode, csv_format)
      if intp_value(errorCode) < 0:
        raise RuntimeError(self.gefm_getErrorString())
      else:
    #print (outputPath)
        return outputPath

    def rref(self, data, tolerance=1e-6):
      """
      LibStructural.rref(self, matrix)

      Computes the reduced row echelon of the given matrix. Tolerance is set to indicate the smallest number consider to be zero.

      :param: A matrix (numpy)
      :param: Optional: tolerance (float), default is 1E-6
      :returns: A reduced row echelon form of the matrix
      """
      import numpy as np
      if (type(data) is list or type(data) is np.ndarray):
            data = np.array(data)
            if data.ndim == 2:
                rows = len(data)
                cols = len(data[0])
                m = DoubleMatrix(rows,cols)
                for i in range(rows):
                    for j in range (cols):
                        m.set (i, j, float(data[i][j]))
                return self._my_rref (m, tolerance).toNumpy()
            else:
                raise ValueError("Expecting 2 dimensional list or numpy array")
      else:
          raise ValueError("Expecting list or numpy array")

    def rref_FB(self, data, tolerance=1e-6):
          """
          LibStructural.rref_FB(self, matrix)

          :param: A matrix
          :returns: The reduced row echelon form of the matrix.
          """

          import numpy as np

          if (type(data) is list or type(data) is np.ndarray):
              data = np.array(data)
              if data.ndim == 2:
                  rows = len(data)
                  cols = len(data[0])
                  m = DoubleMatrix(rows,cols)
                  for i in range(rows):
                      for j in range (cols):
                          m.set (i, j, float(data[i][j]))
                  return self._my_rref_FB (m, tolerance).toNumpy()
              else:
                  raise ValueError("Expecting 2 dimensional list or numpy array")
          else:
              raise ValueError("Expecting list or numpy array")

    def getEigenValues (self, oMatrix):
            """
            LibStructural.getEigenValues(self, matrix)

            :param: Matrix to find the eigenvalues for.
            :returns: An array, first column are the real values and second column are imaginary values
            """

            import numpy as np

            if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
                oMatrix = np.array(oMatrix)
                if oMatrix.ndim == 2:
                    rows = len(oMatrix)
                    cols = len(oMatrix[0])
                    m = DoubleMatrix(rows,cols)
                    for i in range(rows):
                        for j in range (cols):
                            m.set (i, j, float(oMatrix[i][j]))
                    return self._my_getEigenValues(m).toNumpy()
                else:
                    raise ValueError("Expecting 2 dimensional list or numpy array")
            else:
                raise ValueError("Expecting list or numpy array")

    def getEigenVectors (self, oMatrix):
            """
            LibStructural.getEigenVectors(self, matrix)

            :param: Matrix to find the eigenvectors for
            :returns: An array where each columns is an eigenvector
            """

            import numpy as np

            if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
                oMatrix = np.array(oMatrix)
                if oMatrix.ndim == 2:
                    rows = len(oMatrix)
                    cols = len(oMatrix[0])
                    m = DoubleMatrix(rows,cols)
                    for i in range(rows):
                        for j in range (cols):
                            m.set (i, j, float(oMatrix[i][j]))
                    return self._my_getEigenVectors(m).toNumpy()
                else:
                    raise ValueError("Expecting 2 dimensional list or numpy array")
            else:
                raise ValueError("Expecting list or numpy array")

    def getConditionNumber (self, oMatrix):
            '''
            LibStructural.getConditionNumber(self, matrix)

            :param: Takes a matrix (numpy) as an argument. Find the condition number of the matrix.
            :returns: The condition number
            '''
            import numpy as np

            if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
                oMatrix = np.array(oMatrix)
                if oMatrix.ndim == 2:
                    rows = len(oMatrix)
                    cols = len(oMatrix[0])
                    m = DoubleMatrix(rows,cols)
                    for i in range(rows):
                        for j in range (cols):
                            m.set (i, j, float(oMatrix[i][j]))
                    return self._my_getConditionNumber(m)
                else:
                    raise ValueError("Expecting 2 dimensional list or numpy array")
            else:
                raise ValueError("Expecting list or numpy array")

    def getRConditionNumber (self, oMatrix):
            '''
            LibStructural.getRConditionNumber(self, matrix)

            Find the condition number of a matrix.

            :param: A matrix as an argument.
            :returns: The condition number
            '''

            import numpy as np

            if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
                oMatrix = np.array(oMatrix)
                if oMatrix.ndim == 2:
                    rows = len(oMatrix)
                    cols = len(oMatrix[0])
                    m = DoubleMatrix(rows,cols)
                    for i in range(rows):
                        for j in range (cols):
                            m.set (i, j, float(oMatrix[i][j]))
                    return self._my_getRCond(m)
                else:
                    raise ValueError("Expecting 2 dimensional list or numpy array")
            else:
                raise ValueError("Expecting list or numpy array")

    def getLeftNullSpace (self, oMatrix):
            """
            LibStructural.getLeftNullSpace(self, matrix)

            :param: Matrix to find the left nullspace of.
            :returns: The Left Nullspace of the matrix argument.

            """

            import numpy as np

            if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
                oMatrix = np.array(oMatrix)
                if oMatrix.ndim == 2:
                    rows = len(oMatrix)
                    cols = len(oMatrix[0])
                    m = DoubleMatrix(rows,cols)
                    for i in range(rows):
                        for j in range (cols):
                            m.set (i, j, float(oMatrix[i][j]))
                    return self._my_getLeftNullSpace(m).toNumpy()
                else:
                    raise ValueError("Expecting 2 dimensional list or numpy array")
            else:
                raise ValueError("Expecting list or numpy array")

    def getRightNullSpace (self, oMatrix):
            """
            LibStructural.getRightNullSpace(self, matrix)

            :param: Matrix to find the right nullspace of.
            :returns: The Right Nullspace of the matric argument.
            """

            import numpy as np

            if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
                oMatrix = np.array(oMatrix)
                if oMatrix.ndim == 2:
                    rows = len(oMatrix)
                    cols = len(oMatrix[0])
                    m = DoubleMatrix(rows,cols)
                    for i in range(rows):
                        for j in range (cols):
                            m.set (i, j, float(oMatrix[i][j]))
                    return self._my_getRightNullSpace(m).toNumpy()
                else:
                    raise ValueError("Expecting 2 dimensional list or numpy array")
            else:
                raise ValueError("Expecting list or numpy array")

    def getRank (self, oMatrix):
            """
            LibStructural.getRank(self, matrix)

            :param: Matrix to find the rank of.
            :returns: The rank as an integer.
            """
            import numpy as np

            if (type(oMatrix) is list or type(oMatrix) is np.ndarray):
                oMatrix = np.array(oMatrix)
                if oMatrix.ndim == 2:
                    rows = len(oMatrix)
                    cols = len(oMatrix[0])
                    m = DoubleMatrix(rows,cols)
                    for i in range(rows):
                        for j in range (cols):
                            m.set (i, j, float(oMatrix[i][j]))
                    return self._my_getRank(m)
                else:
                    raise ValueError("Expecting 2 dimensional list or numpy array")
            else:
                raise ValueError("Expecting list or numpy array")


    def runLibstructTests(self):
      """
      LibStructural.runLibstructTests(self)

      :returns: A summary of test results on the integrity of structural methods.

      """
      import sys
      if sys.version_info[0] < 3:
          import test.testLibStructuralSBML
          test.testLibStructuralSBML.run()
      else:
          from structural.test import testLibStructuralSBML
          testLibStructuralSBML.run()


    def runElementaryModeTests(self):
      """
      LibStructural.runElementaryModeTests(self)

      :returns: A valididty test result of elementary modes generated from 31 models.

      """
      import sys
      if sys.version_info[0] < 3:
          import test.testElementaryModesUsingSBML
          test.testElementaryModesUsingSBML.run()
      else:
          from structural.test import testElementaryModesUsingSBML
          testElementaryModesUsingSBML.run()


    def getElementaryModesDouble(self):
      """
      LibStructural.getElementaryModesDouble(self)

      :returns: An array where each column is an elementary mode (Generated from MetaTool)

      """
      import numpy as np
      import tempfile
      import subprocess
      import site
      import os
      import pkg_resources
      import platform
      import stat

      mStr = ''

      rxn_ids = self.getReactionIds()
      flt_ids = self.getFloatingSpeciesIds()
      bnd_ids = self.getBoundarySpeciesIds()
      matx_bnd = self.getStoichiometryMatrixBoundary()
      matx_flt = self.getStoichiometryMatrix()

      if len(bnd_ids) == 0:
        matx = matx_flt
        spec_ids = list(flt_ids)
      else:
        matx = matx_bnd
        spec_ids = list(flt_ids) + list(bnd_ids)


      mStr += "-ENZREV" + "\n"

      for i in range(len(rxn_ids)):
          if self.isReactionReversible(i):
              mStr += rxn_ids[i] + " "

      mStr += "\n\n"+"-ENZIRREV" + "\n"

      for i in range(len(rxn_ids)):
          if not self.isReactionReversible(i):
              mStr += rxn_ids[i] + " "

      mStr += "\n\n"+"-METINT"+"\n"

      for  i in flt_ids:
          mStr += str (i) + " "

      mStr += "\n\n"+"-METEXT"+"\n"

      if len(bnd_ids) != 0:
        for i in bnd_ids:
          mStr += i + " "

      mStr += "\n\n"+"-CAT"+"\n"

      for i in range(len(rxn_ids)):
          react_list = []
          col = matx[:,i]
          mStr += rxn_ids[i] + " : "

          for j in range(len(matx)):
              if matx[j,i] < 0:
                  stStr = ''
                  if abs(matx[j,i]) > 1:
                      stStr = str(abs(matx[j,i])) + ' '
                  react_list.append(stStr + spec_ids[j])
          mStr += react_list[0]
          for k in range(1,len(react_list)):
              mStr += " + " + react_list[k]
          mStr += " = "

          prod_list = []
          for j in range(len(matx)):
              if matx[j,i] > 0:
                  stStr = ''
                  if matx[j,i] > 1:
                      stStr = str(matx[j,i]) + ' '
                  prod_list.append(stStr + spec_ids[j])

          if len(prod_list) != 0:
            mStr += prod_list[0]
            for k in range(1,len(prod_list)):
              mStr += " + " + prod_list[k]

          mStr += " .\n"


      f = tempfile.NamedTemporaryFile(delete=False)
      d = tempfile.gettempdir()

      resultFile = os.path.join(d,"MetaToolResult.txt")
      metatoolFile = f.name
      with open(metatoolFile, "w") as f:
        f.write (mStr)
      f.close()

      if platform.system() == 'Windows':
          pathToMetatool = pkg_resources.resource_filename('structural', 'metaToolDouble.exe')
      else:
          pathToMetatool = pkg_resources.resource_filename('structural', 'metaToolDouble')

      st = os.stat(pathToMetatool)
      os.chmod(pathToMetatool, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

      with open(os.devnull, "w") as f:
          exit_code = subprocess.call ([pathToMetatool, metatoolFile, resultFile], stdout=f)


      if os.path.isfile(resultFile):
        if exit_code == 0:
            line_array = []
            with open(resultFile) as f:
                for lines in f:
                    line_array.append(lines)

            start_pt = line_array.index("ELEMENTARY MODES\n")

            if line_array[start_pt+1] == ' \n':
                row_num = int(line_array[start_pt+2].split()[2].replace("r", ""))

                elementaryModeMatrix = []
                for i in range(row_num):
                    elementaryModeMatrix.append(line_array[start_pt+3+i].split())
                elementaryModeMatrix = np.array(elementaryModeMatrix, dtype=float)
                f.close()
                return elementaryModeMatrix
            else:
                return np.empty([0,0])
        else:
            raise RuntimeError(MetaToolexitCodeDict[-exit_code])
      else:
         raise RuntimeError ("Internal Error: Result file from MetaTool not found")


    def getElementaryModesIntegerRxnIds(self):
      """
      LibStructural.getElementaryModesIntegerRxnIds(self)

      :returns: An array of reaction Ids corresponding with the columns of getElementaryModesInteger() matrix.

      """
      return list(self.getReactionIds())


    def getElementaryModesDoubleRxnIds(self):
      """
      LibStructural.getElementaryModesDoubleRxnIds(self)

      :returns: An array of reaction Ids corresponding with the columns of getElementaryModesDouble() matrix.

      """

      import os
      import tempfile

      rxn_ids = self.getReactionIds()
      rxnId_lst = []

      for i in range(len(rxn_ids)):
          if self.isReactionReversible(i):
              rxnId_lst.append(rxn_ids[i])

      for i in range(len(rxn_ids)):
          if not self.isReactionReversible(i):
              rxnId_lst.append(rxn_ids[i])

      return rxnId_lst


    __swig_destroy__ = _structural.delete_LibStructural
    __del__ = lambda self: None
LibStructural_swigregister = _structural.LibStructural_swigregister
LibStructural_swigregister(LibStructural)

def LibStructural_getInstance():
    """

    LibStructural.getInstance(self)

    static method to get an instance of LibStructural (allows use as singleton)

    .. code:: python

    import structural
    ls = structural.LibStructural.getInstance()

    .. end


    """
    return _structural.LibStructural_getInstance()

class NoModelException(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoModelException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NoModelException, name)
    __repr__ = _swig_repr

    def __init__(self, message):
        this = _structural.new_NoModelException(message)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getMessage(self):
        return _structural.NoModelException_getMessage(self)
    __swig_destroy__ = _structural.delete_NoModelException
    __del__ = lambda self: None
NoModelException_swigregister = _structural.NoModelException_swigregister
NoModelException_swigregister(NoModelException)

class ApplicationException(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApplicationException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ApplicationException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _structural.new_ApplicationException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getMessage(self):
        return _structural.ApplicationException_getMessage(self)

    def getDetailedMessage(self):
        return _structural.ApplicationException_getDetailedMessage(self)
    __swig_destroy__ = _structural.delete_ApplicationException
    __del__ = lambda self: None
ApplicationException_swigregister = _structural.ApplicationException_swigregister
ApplicationException_swigregister(ApplicationException)

class Util(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Util, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Util, name)
    __repr__ = _swig_repr
    if _newclass:
        checkTolerance = staticmethod(_structural.Util_checkTolerance)
    else:
        checkTolerance = _structural.Util_checkTolerance
    if _newclass:
        getSubMatrix = staticmethod(_structural.Util_getSubMatrix)
    else:
        getSubMatrix = _structural.Util_getSubMatrix
    if _newclass:
        matMult = staticmethod(_structural.Util_matMult)
    else:
        matMult = _structural.Util_matMult
    if _newclass:
        isPositive = staticmethod(_structural.Util_isPositive)
    else:
        isPositive = _structural.Util_isPositive
    if _newclass:
        CopyMatrix = staticmethod(_structural.Util_CopyMatrix)
    else:
        CopyMatrix = _structural.Util_CopyMatrix
    if _newclass:
        CopyStringVector = staticmethod(_structural.Util_CopyStringVector)
    else:
        CopyStringVector = _structural.Util_CopyStringVector
    if _newclass:
        CopyDoubleVector = staticmethod(_structural.Util_CopyDoubleVector)
    else:
        CopyDoubleVector = _structural.Util_CopyDoubleVector
    if _newclass:
        CopyIntVector = staticmethod(_structural.Util_CopyIntVector)
    else:
        CopyIntVector = _structural.Util_CopyIntVector
    if _newclass:
        CopyComplexVector = staticmethod(_structural.Util_CopyComplexVector)
    else:
        CopyComplexVector = _structural.Util_CopyComplexVector
    if _newclass:
        RoundMatrixToTolerance = staticmethod(_structural.Util_RoundMatrixToTolerance)
    else:
        RoundMatrixToTolerance = _structural.Util_RoundMatrixToTolerance
    if _newclass:
        RoundToTolerance = staticmethod(_structural.Util_RoundToTolerance)
    else:
        RoundToTolerance = _structural.Util_RoundToTolerance
    if _newclass:
        GaussJordan = staticmethod(_structural.Util_GaussJordan)
    else:
        GaussJordan = _structural.Util_GaussJordan
    if _newclass:
        FullyPivotedGaussJordan = staticmethod(_structural.Util_FullyPivotedGaussJordan)
    else:
        FullyPivotedGaussJordan = _structural.Util_FullyPivotedGaussJordan
    if _newclass:
        gaussJordan = staticmethod(_structural.Util_gaussJordan)
    else:
        gaussJordan = _structural.Util_gaussJordan
    if _newclass:
        findRank = staticmethod(_structural.Util_findRank)
    else:
        findRank = _structural.Util_findRank
    if _newclass:
        _print = staticmethod(_structural.Util__print)
    else:
        _print = _structural.Util__print

    def __init__(self):
        this = _structural.new_Util()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _structural.delete_Util
    __del__ = lambda self: None
Util_swigregister = _structural.Util_swigregister
Util_swigregister(Util)

def Util_checkTolerance(*args):
    return _structural.Util_checkTolerance(*args)
Util_checkTolerance = _structural.Util_checkTolerance

def Util_getSubMatrix(Mb, Nb, ms, ns, mi, nj, A):
    return _structural.Util_getSubMatrix(Mb, Nb, ms, ns, mi, nj, A)
Util_getSubMatrix = _structural.Util_getSubMatrix

def Util_matMult(*args):
    return _structural.Util_matMult(*args)
Util_matMult = _structural.Util_matMult

def Util_isPositive(A, dTolerance):
    return _structural.Util_isPositive(A, dTolerance)
Util_isPositive = _structural.Util_isPositive

def Util_CopyMatrix(*args):
    return _structural.Util_CopyMatrix(*args)
Util_CopyMatrix = _structural.Util_CopyMatrix

def Util_CopyStringVector(vector, outVector, outLength):
    return _structural.Util_CopyStringVector(vector, outVector, outLength)
Util_CopyStringVector = _structural.Util_CopyStringVector

def Util_CopyDoubleVector(vector, outVector, outLength):
    return _structural.Util_CopyDoubleVector(vector, outVector, outLength)
Util_CopyDoubleVector = _structural.Util_CopyDoubleVector

def Util_CopyIntVector(vector, outVector, outLength):
    return _structural.Util_CopyIntVector(vector, outVector, outLength)
Util_CopyIntVector = _structural.Util_CopyIntVector

def Util_CopyComplexVector(vector, outVectorReal, outVectorImag, outLength):
    return _structural.Util_CopyComplexVector(vector, outVectorReal, outVectorImag, outLength)
Util_CopyComplexVector = _structural.Util_CopyComplexVector

def Util_RoundMatrixToTolerance(oMatrix, dTolerance):
    return _structural.Util_RoundMatrixToTolerance(oMatrix, dTolerance)
Util_RoundMatrixToTolerance = _structural.Util_RoundMatrixToTolerance

def Util_RoundToTolerance(dValue, dTolerance):
    return _structural.Util_RoundToTolerance(dValue, dTolerance)
Util_RoundToTolerance = _structural.Util_RoundToTolerance

def Util_GaussJordan(oMatrix, dTolerance):
    return _structural.Util_GaussJordan(oMatrix, dTolerance)
Util_GaussJordan = _structural.Util_GaussJordan

def Util_FullyPivotedGaussJordan(oMatrix, dTolerance, rowPivots, colPivots):
    return _structural.Util_FullyPivotedGaussJordan(oMatrix, dTolerance, rowPivots, colPivots)
Util_FullyPivotedGaussJordan = _structural.Util_FullyPivotedGaussJordan

def Util_gaussJordan(oMatrix, dTolerance):
    return _structural.Util_gaussJordan(oMatrix, dTolerance)
Util_gaussJordan = _structural.Util_gaussJordan

def Util_findRank(oMatrix, dTolerance):
    return _structural.Util_findRank(oMatrix, dTolerance)
Util_findRank = _structural.Util_findRank

def Util__print(*args):
    return _structural.Util__print(*args)
Util__print = _structural.Util__print

class complexArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, complexArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, complexArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _structural.new_complexArray(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _structural.delete_complexArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _structural.complexArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _structural.complexArray___setitem__(self, index, value)

    def cast(self):
        return _structural.complexArray_cast(self)
    if _newclass:
        frompointer = staticmethod(_structural.complexArray_frompointer)
    else:
        frompointer = _structural.complexArray_frompointer
complexArray_swigregister = _structural.complexArray_swigregister
complexArray_swigregister(complexArray)

def complexArray_frompointer(t):
    return _structural.complexArray_frompointer(t)
complexArray_frompointer = _structural.complexArray_frompointer

class doubleArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _structural.new_doubleArray(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _structural.delete_doubleArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _structural.doubleArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _structural.doubleArray___setitem__(self, index, value)

    def cast(self):
        return _structural.doubleArray_cast(self)
    if _newclass:
        frompointer = staticmethod(_structural.doubleArray_frompointer)
    else:
        frompointer = _structural.doubleArray_frompointer
doubleArray_swigregister = _structural.doubleArray_swigregister
doubleArray_swigregister(doubleArray)

def doubleArray_frompointer(t):
    return _structural.doubleArray_frompointer(t)
doubleArray_frompointer = _structural.doubleArray_frompointer

class intArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _structural.new_intArray(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _structural.delete_intArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _structural.intArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _structural.intArray___setitem__(self, index, value)

    def cast(self):
        return _structural.intArray_cast(self)
    if _newclass:
        frompointer = staticmethod(_structural.intArray_frompointer)
    else:
        frompointer = _structural.intArray_frompointer
intArray_swigregister = _structural.intArray_swigregister
intArray_swigregister(intArray)

def intArray_frompointer(t):
    return _structural.intArray_frompointer(t)
intArray_frompointer = _structural.intArray_frompointer

class DoubleMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _structural.new_DoubleMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getArray(self):
        return _structural.DoubleMatrix_getArray(self)

    def getCopy(self, transpose=False):
        return _structural.DoubleMatrix_getCopy(self, transpose)

    def initializeFrom2DMatrix(self, oRawData, nRows, nCols):
        return _structural.DoubleMatrix_initializeFrom2DMatrix(self, oRawData, nRows, nCols)

    def initializeFromConst2DMatrix(self, oRawData, nRows, nCols):
        return _structural.DoubleMatrix_initializeFromConst2DMatrix(self, oRawData, nRows, nCols)
    __swig_destroy__ = _structural.delete_DoubleMatrix
    __del__ = lambda self: None

    def get2DMatrix(self, nRows, nCols):
        return _structural.DoubleMatrix_get2DMatrix(self, nRows, nCols)

    def swapRows(self, row1, row2):
        return _structural.DoubleMatrix_swapRows(self, row1, row2)

    def swapCols(self, col1, col2):
        return _structural.DoubleMatrix_swapCols(self, col1, col2)

    def resize(self, rows, cols):
        return _structural.DoubleMatrix_resize(self, rows, cols)

    def getTranspose(self):
        return _structural.DoubleMatrix_getTranspose(self)

    def size(self):
        return _structural.DoubleMatrix_size(self)

    def numRows(self):
        return _structural.DoubleMatrix_numRows(self)

    def numCols(self):
        return _structural.DoubleMatrix_numCols(self)

    def __call__(self, *args):
        return _structural.DoubleMatrix___call__(self, *args)

    def get(self, row, col):
        return _structural.DoubleMatrix_get(self, row, col)

    def set(self, row, col, value):
        return _structural.DoubleMatrix_set(self, row, col, value)

    def toNumpy(self):
            import numpy as np
            result = np.zeros((self.numRows(), self.numCols()))
            for i in range(self.numRows()):
                    for j in range(self.numCols()):
                            result[i,j] = self.get(i,j)
            return result
    def __repr__(self):
            return self.toNumpy().__repr__()

DoubleMatrix_swigregister = _structural.DoubleMatrix_swigregister
DoubleMatrix_swigregister(DoubleMatrix)

class IntMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _structural.new_IntMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getArray(self):
        return _structural.IntMatrix_getArray(self)

    def getCopy(self, transpose=False):
        return _structural.IntMatrix_getCopy(self, transpose)

    def initializeFrom2DMatrix(self, oRawData, nRows, nCols):
        return _structural.IntMatrix_initializeFrom2DMatrix(self, oRawData, nRows, nCols)

    def initializeFromConst2DMatrix(self, oRawData, nRows, nCols):
        return _structural.IntMatrix_initializeFromConst2DMatrix(self, oRawData, nRows, nCols)
    __swig_destroy__ = _structural.delete_IntMatrix
    __del__ = lambda self: None

    def get2DMatrix(self, nRows, nCols):
        return _structural.IntMatrix_get2DMatrix(self, nRows, nCols)

    def swapRows(self, row1, row2):
        return _structural.IntMatrix_swapRows(self, row1, row2)

    def swapCols(self, col1, col2):
        return _structural.IntMatrix_swapCols(self, col1, col2)

    def resize(self, rows, cols):
        return _structural.IntMatrix_resize(self, rows, cols)

    def getTranspose(self):
        return _structural.IntMatrix_getTranspose(self)

    def size(self):
        return _structural.IntMatrix_size(self)

    def numRows(self):
        return _structural.IntMatrix_numRows(self)

    def numCols(self):
        return _structural.IntMatrix_numCols(self)

    def __call__(self, *args):
        return _structural.IntMatrix___call__(self, *args)

    def get(self, row, col):
        return _structural.IntMatrix_get(self, row, col)

    def set(self, row, col, value):
        return _structural.IntMatrix_set(self, row, col, value)

    def toNumpy(self):
            import numpy as np
            print ("Num Rows", self.numRows())
            print ("Num Cols", self.numCols())
            result = np.zeros((self.numRows(), self.numCols()), dtype=np.int)
            for i in range(self.numRows()):
                    for j in range(self.numCols()):
                            result[i,j] = self.get(i,j)
            return result
    def __repr__(self):
            return self.toNumpy().__repr__()

IntMatrix_swigregister = _structural.IntMatrix_swigregister
IntMatrix_swigregister(IntMatrix)

class ComplexMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _structural.new_ComplexMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getArray(self):
        return _structural.ComplexMatrix_getArray(self)

    def getCopy(self, transpose=False):
        return _structural.ComplexMatrix_getCopy(self, transpose)

    def initializeFrom2DMatrix(self, oRawData, nRows, nCols):
        return _structural.ComplexMatrix_initializeFrom2DMatrix(self, oRawData, nRows, nCols)

    def initializeFromConst2DMatrix(self, oRawData, nRows, nCols):
        return _structural.ComplexMatrix_initializeFromConst2DMatrix(self, oRawData, nRows, nCols)
    __swig_destroy__ = _structural.delete_ComplexMatrix
    __del__ = lambda self: None

    def get2DMatrix(self, nRows, nCols):
        return _structural.ComplexMatrix_get2DMatrix(self, nRows, nCols)

    def swapRows(self, row1, row2):
        return _structural.ComplexMatrix_swapRows(self, row1, row2)

    def swapCols(self, col1, col2):
        return _structural.ComplexMatrix_swapCols(self, col1, col2)

    def resize(self, rows, cols):
        return _structural.ComplexMatrix_resize(self, rows, cols)

    def getTranspose(self):
        return _structural.ComplexMatrix_getTranspose(self)

    def size(self):
        return _structural.ComplexMatrix_size(self)

    def numRows(self):
        return _structural.ComplexMatrix_numRows(self)

    def numCols(self):
        return _structural.ComplexMatrix_numCols(self)

    def __call__(self, *args):
        return _structural.ComplexMatrix___call__(self, *args)

    def get(self, row, col):
        return _structural.ComplexMatrix_get(self, row, col)

    def set(self, row, col, value):
        return _structural.ComplexMatrix_set(self, row, col, value)

    def toNumpy(self):
            import numpy as np
            result = np.zeros((self.numRows(), self.numCols()), dtype=np.complex_)
            for i in range(self.numRows()):
                    for j in range(self.numCols()):
                            result[i,j] = self.getReal(i,j) + self.getImag(i,j)*1j
            return result
    def __repr__(self):
            return self.toNumpy().__repr__()

ComplexMatrix_swigregister = _structural.ComplexMatrix_swigregister
ComplexMatrix_swigregister(ComplexMatrix)

# This file is compatible with both classic and new-style classes.


