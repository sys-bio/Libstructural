<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Structural Analysis Library: doc_extension_sbmlextension Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Structural Analysis Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">doc_extension_sbmlextension Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;common-documentation.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section user"><dt></dt><dd>Each package implementation must contain a class that extends <a class="el" href="class_s_b_m_l_extension.html">SBMLExtension</a>. For example, the class <code>GroupsExtension</code> serves this purpose for the SBML Level&#160;3 <em>Groups</em> package extension in libSBML. The following subsections detail the basic steps involved in implementing such an extended class.</dd></dl>
<p>Define a method named <code>getPackageName()</code> that returns the name of the package as a string. The following is an example from the implementation of the Groups package extension: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::string&amp; GroupsExtension::getPackageName ()</div><div class="line">{</div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> std::string pkgName = <span class="stringliteral">&quot;groups&quot;</span>;</div><div class="line">      <span class="keywordflow">return</span> pkgName;</div><div class="line">}</div></div><!-- fragment --><p>Define a set of methods that return the default SBML Level, SBML Version and version of the package. These methods must be named <code>getDefaultLevel()</code>, <code>getDefaultVersion()</code> and <code>getDefaultPackageVersion()</code>, respectively. The following are examples drawn from the Groups package implementation: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GroupsExtension::getDefaultLevel()</div><div class="line">{</div><div class="line">      <span class="keywordflow">return</span> 3;</div><div class="line">}</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GroupsExtension::getDefaultVersion()</div><div class="line">{</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">}</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GroupsExtension::getDefaultPackageVersion()</div><div class="line">{</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">}</div></div><!-- fragment --><p>Define methods that return strings representing the XML namespace URI for the package. One method should be defined for each SBML Level/Version combination for which the package can be used. For instance, if a package is only usable in SBML Level&#160;3 Version&#160;1, and the libSBML extension for the package implements version&#160;1 of the package, the necessary method is <code>getXmlnsL3V1V1()</code>. </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::string&amp; GroupsExtension::getXmlnsL3V1V1 ()</div><div class="line">{</div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> std::string xmlns = <span class="stringliteral">&quot;http://www.sbml.org/sbml/level3/version1/groups/version1&quot;</span>;</div><div class="line">      <span class="keywordflow">return</span> xmlns;</div><div class="line">}</div></div><!-- fragment --><p>Define other similar methods to return additional namespace URIs if the package extension implements other package versions or supports other SBML Level/Version combinations.</p>
<p>Override the following pure virtual methods on <a class="el" href="class_s_b_m_l_extension.html">SBMLExtension</a>:</p>
<ul>
<li><code>virtual const std::string&amp; getName() const =0</code>. This method returns the nickname of the package (e.g., "layout", "groups").</li>
</ul>
<ul>
<li><code>virtual unsigned int getLevel(const std::string &amp;uri) const =0</code>. This method returns the SBML Level with the given URI of this package.</li>
</ul>
<ul>
<li><code>virtual unsigned int getVersion(const std::string &amp;uri) const =0</code>. This method returns the SBML Version with the given URI of this package.</li>
</ul>
<ul>
<li><code>virtual unsigned int getPackageVersion(const std::string &amp;uri) const =0</code>. This method returns the package version with the given URI of this package.</li>
</ul>
<ul>
<li><code>virtual unsigned int getURI(unsigned int sbmlLevel, unsigned int sbmlVersion, unsigned int pkgVersion) const =0</code>. This method returns the URI (namespace) of the package corresponding to the combination of the given SBML Level, SBML Version, and package version</li>
</ul>
<ul>
<li><code>virtual SBMLExtension* clone() const = 0</code>. This method creates and returns a deep copy of this derived object.</li>
</ul>
<p>As an example, the following are the versions of these methods for the Groups package: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::string&amp; GroupsExtension::getName()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> getPackageName();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GroupsExtension::getLevel(<span class="keyword">const</span> std::string &amp;uri)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (uri == getXmlnsL3V1V1())</div><div class="line">    <span class="keywordflow">return</span> 3;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="libstructural_8cpp.html#a197ace0ff709d82e38564777071f6826">GroupsExtension::getVersion</a>(<span class="keyword">const</span> std::string &amp;uri)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (uri == getXmlnsL3V1V1())</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GroupsExtension::getPackageVersion(<span class="keyword">const</span> std::string &amp;uri)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (uri == getXmlnsL3V1V1())</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::string&amp; GroupsExtension::getURI(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sbmlLevel,</div><div class="line">                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sbmlVersion,</div><div class="line">                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pkgVersion)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (sbmlLevel == 3 &amp;&amp; sbmlVersion == 1 &amp;&amp; pkgVersion == 1)</div><div class="line">    <span class="keywordflow">return</span> getXmlnsL3V1V1();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::string empty = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">  <span class="keywordflow">return</span> empty;</div><div class="line">}</div><div class="line"></div><div class="line">GroupsExtension* GroupsExtension::clone()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">new</span> GroupsExtension(*<span class="keyword">this</span>);</div><div class="line">}</div></div><!-- fragment --><p>Constructor, copy constructor, and destructor methods also must be overridden if additional data members are defined in the derived class.</p>
<p>Define typedef and template instantiation code for a package-specific subclass of the <a class="el" href="class_s_b_m_l_extension_namespaces.html">SBMLExtensionNamespaces</a> template class. The <a class="el" href="class_s_b_m_l_extension_namespaces.html">SBMLExtensionNamespaces</a> template class is a derived class of <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> and can be used as an argument of constructors of SBase-derived classes defined in the package extensions.</p>
<ol>
<li>
<p class="startli">Define a typedef. For example, the typedef for <code>GroupsExtension</code> is implemented in the file <code>GroupsExtension.h</code> as follows: </p><div class="fragment"><div class="line"><span class="comment">// GroupsPkgNamespaces is derived from the SBMLNamespaces class.</span></div><div class="line"><span class="comment">// It is used when creating a Groups package object of a class</span></div><div class="line"><span class="comment">// derived from SBase.</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="class_s_b_m_l_extension_namespaces.html">SBMLExtensionNamespaces&lt;GroupsExtension&gt;</a> GroupsPkgNamespaces;</div></div><!-- fragment --> <p class="endli"></p>
</li>
<li>
<p class="startli">Define a template instantiation for the typedef. For example, the template instantiation code for <code>GroupsExtension is</code> implemented in the file <code>GroupsExtension.cpp</code> as follows: </p><div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="code" href="class_s_b_m_l_extension_namespaces.html">SBMLExtensionNamespaces&lt;GroupsExtension&gt;</a>;</div></div><!-- fragment --> <p class="endli"></p>
</li>
</ol>
<p>Here is example of how the resulting class is used. The definitions above allow a <code>GroupsPkgNamespaces</code> object to be used when creating a new <code>Group</code> object. The <code>GroupsPkgNamespaces</code> is handed to the constructor as an argument, as shown below: </p><div class="fragment"><div class="line">GroupPkgNamespaces gpns(3, 1, 1);  <span class="comment">// SBML Level, Version, &amp; pkg version.</span></div><div class="line">Group g = <span class="keyword">new</span> Group(&amp;gpns);        <span class="comment">// Creates a Group object.</span></div></div><!-- fragment --><p>The <code>GroupsPkgNamespaces</code> object can also be used when creating an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object with the Groups package. The code fragment below shows an example of this: </p><div class="fragment"><div class="line">GroupsPkgNamespaces gpns(3, 1, 1);</div><div class="line"><a class="code" href="class_s_b_m_l_document.html">SBMLDocument</a>* doc;</div><div class="line">doc  = <span class="keyword">new</span> <a class="code" href="class_s_b_m_l_document.html">SBMLDocument</a>(&amp;gnps);</div></div><!-- fragment --><p>Override the pure virtual method <code>getSBMLExtensionNamespaces()</code>, which returns an <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> derived object. For example, the method is overridden in the class <code>GroupsExtension</code> as follows: </p><div class="fragment"><div class="line"><a class="code" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a>*</div><div class="line">GroupsExtension::getSBMLExtensionNamespaces(<span class="keyword">const</span> std::string &amp;uri)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  GroupsPkgNamespaces* pkgns = <a class="code" href="lp__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line">  <span class="keywordflow">if</span> ( uri == getXmlnsL3V1V1())</div><div class="line">  {</div><div class="line">    pkgns = <span class="keyword">new</span> GroupsPkgNamespaces(3, 1, 1);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> pkgns;</div><div class="line">}</div></div><!-- fragment --><p>Define an enum type for representing the type code of the objects defined in the package extension. For example, the enumeration <code>SBMLGroupsTypeCode_t</code> for the Groups package is defined in <code>GroupsExtension.h</code> as follows: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div><div class="line">{</div><div class="line">   SBML_GROUPS_GROUP  = 500</div><div class="line"> , SBML_GROUPS_MEMBER = 501</div><div class="line">} SBMLGroupsTypeCode_t;</div></div><!-- fragment --><p>In the enumeration above, <code>SBML_GROUPS_GROUP</code> corresponds to the <code>Group</code> class (for the <code>&lt;group&gt;</code> element defined by the SBML Level&#160;3 Groups package) and <code>SBML_GROUPS_MEMBER</code> corresponds to the <code>Member</code> class (for the <code>&lt;member&gt;</code> element defined by the Level&#160;3 Groups package), respectively.</p>
<p>Similarly, #SBMLLayoutTypeCode_t for the Layout package is defined in the file <code>LayoutExtension.h</code> as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div><div class="line">{</div><div class="line">   SBML_LAYOUT_BOUNDINGBOX           = 100</div><div class="line"> , SBML_LAYOUT_COMPARTMENTGLYPH      = 101</div><div class="line"> , SBML_LAYOUT_CUBICBEZIER           = 102</div><div class="line"> , SBML_LAYOUT_CURVE                 = 103</div><div class="line"> , SBML_LAYOUT_DIMENSIONS            = 104</div><div class="line"> , SBML_LAYOUT_GRAPHICALOBJECT       = 105</div><div class="line"> , SBML_LAYOUT_LAYOUT                = 106</div><div class="line"> , SBML_LAYOUT_LINESEGMENT           = 107</div><div class="line"> , SBML_LAYOUT_POINT                 = 108</div><div class="line"> , SBML_LAYOUT_REACTIONGLYPH         = 109</div><div class="line"> , SBML_LAYOUT_SPECIESGLYPH          = 110</div><div class="line"> , SBML_LAYOUT_SPECIESREFERENCEGLYPH = 111</div><div class="line"> , SBML_LAYOUT_TEXTGLYPH             = 112</div><div class="line">} SBMLLayoutTypeCode_t;</div></div><!-- fragment --><p>These enum values are returned by corresponding <code>getTypeCode()</code> methods. (E.g., <code>SBML_GROUPS_GROUP</code> is returned in <code>Group::getTypeCode()</code>.)</p>
<p>Note that libSBML does not require that type codes are unique across all packages&mdash;the same type codes may be used within individual package extensions. LibSBML development must permit this because package implementations are developed by separate groups at different times; coordinating the type codes used is impractical. It does mean that callers must check two things when identifying objects: to distinguish the type codes of different packages, callers much check not only the return value of the method <code>getTypeCode()</code> method but also that of the method <code>getPackageName()</code>. Here is an example of doing that: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> example (<span class="keyword">const</span> <a class="code" href="class_s_base.html">SBase</a> *sb)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string pkgName = sb-&gt;getPackageName();</div><div class="line">  <span class="keywordflow">if</span> (pkgName == <span class="stringliteral">&quot;core&quot;</span>) {</div><div class="line">    <span class="keywordflow">switch</span> (sb-&gt;getTypeCode()) {</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea3c866be107d7858b6dd1e978ed103028">SBML_MODEL</a>:</div><div class="line">         ....</div><div class="line">         <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea54de874fd61e13450bdf024d41a336c9">SBML_REACTION</a>:</div><div class="line">         ....</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pkgName == <span class="stringliteral">&quot;layout&quot;</span>) {</div><div class="line">    <span class="keywordflow">switch</span> (sb-&gt;getTypeCode()) {</div><div class="line">      <span class="keywordflow">case</span> SBML_LAYOUT_LAYOUT:</div><div class="line">         ....</div><div class="line">         <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> SBML_LAYOUT_REACTIONGLYPH:</div><div class="line">         ....</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pkgName == <span class="stringliteral">&quot;groups&quot;</span>) {</div><div class="line">    <span class="keywordflow">switch</span> (sb-&gt;getTypeCode()) {</div><div class="line">      <span class="keywordflow">case</span> SBML_GROUPS_GROUP:</div><div class="line">         ....</div><div class="line">         <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> SBML_GROUPS_MEMBER:</div><div class="line">         ....</div><div class="line">    }</div><div class="line">  }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>Readers may have noticed that in the #SBMLLayoutTypeCode_t and <code>SBMLGroupsTypeCode_t</code> enumerations above, unique values are in fact assigned to the enumeration values. This can be convenient when it can be arranged, but it is not required by libSBML.</p>
<p>Override the pure virtual method <code>getStringFromTypeCode()</code>, which returns a string corresponding to the given type code. Here is an example, again drawn from the implementation of the Groups package: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="class_s_b_m_l_extension.html">SBMLExtension</a>::(<span class="keywordtype">int</span> typeCode) <span class="keyword">const</span>;</div></div><!-- fragment --><p>For example, the method for the Groups extension is implemented as shown below: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* SBML_GROUPS_TYPECODE_STRINGS[] =</div><div class="line">{</div><div class="line">    <span class="stringliteral">&quot;Group&quot;</span></div><div class="line">  , <span class="stringliteral">&quot;Member&quot;</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* GroupsExtension::getStringFromTypeCode(<span class="keywordtype">int</span> typeCode)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="dependencies_2third-party_2clapack_23_82_81_2_f2_c_l_i_b_s_2libf2c_2f2c_8h.html#ac6afabdc09a49a433ee19d8a9486056d">min</a> = SBML_GROUPS_GROUP;</div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="dependencies_2third-party_2clapack_23_82_81_2_f2_c_l_i_b_s_2libf2c_2f2c_8h.html#affe776513b24d84b39af8ab0930fef7f">max</a> = SBML_GROUPS_MEMBER;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (typeCode &lt; min || typeCode &gt; max)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(Unknown SBML Groups Type)&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> SBML_GROUPS_TYPECODE_STRINGS[typeCode - <a class="code" href="dependencies_2third-party_2clapack_23_82_81_2_f2_c_l_i_b_s_2libf2c_2f2c_8h.html#ac6afabdc09a49a433ee19d8a9486056d">min</a>];</div><div class="line">}</div></div><!-- fragment --><p>Implement a <code>static void init()</code> method in the derived class. This method serves to encapsulate initialization code that creates an instance of the derived class and registration code that registers the instance with the <a class="el" href="class_s_b_m_l_extension_registry.html">SBMLExtensionRegistry</a> class.</p>
<p>For example, the <code>init()</code> method for the Groups package is implemented as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> GroupsExtension::init()</div><div class="line">{</div><div class="line">  <span class="comment">// 1. Check if the Groups package has already been registered.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( SBMLExtensionRegistry::getInstance().isRegistered(getPackageName()) )</div><div class="line">  {</div><div class="line">    <span class="comment">// do nothing;</span></div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// 2. Create an SBMLExtension derived object.</span></div><div class="line"></div><div class="line">  GroupsExtension gext;</div><div class="line"></div><div class="line">  <span class="comment">// 3. Create SBasePluginCreator-derived objects. The derived classes</span></div><div class="line">  <span class="comment">// can be instantiated by using the following template class:</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">//   template&lt;class SBasePluginType&gt; class SBasePluginCreator</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// The constructor of the creator class takes two arguments:</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// 1) SBaseExtensionPoint: extension point to which the plugin connects</span></div><div class="line">  <span class="comment">// 2) std::vector&lt;std::string&gt;: a vector that contains a list of URI</span></div><div class="line">  <span class="comment">// (package versions) supported by the plugin object.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// For example, two plugin objects are required as part of the Groups</span></div><div class="line">  <span class="comment">// implementation: one plugged into SBMLDocument and one into Model.</span></div><div class="line">  <span class="comment">// For the former, since the specification for the SBML Groups package</span></div><div class="line">  <span class="comment">// mandates that the &#39;required&#39; flag is always &#39;false&#39;, the existing</span></div><div class="line">  <span class="comment">// SBMLDocumentPluginNotRequired class can be used as-is as part of</span></div><div class="line">  <span class="comment">// the implementation.  For Model, since the lists of supported</span></div><div class="line">  <span class="comment">// package versions (currently only SBML L3V1 Groups V1) are equal</span></div><div class="line">  <span class="comment">// in the both plugin objects, the same vector can be handed to each</span></div><div class="line">  <span class="comment">// constructor.</span></div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; pkgURIs;</div><div class="line">  pkgURIs.push_back(getXmlnsL3V1V1());</div><div class="line"></div><div class="line">  <a class="code" href="class_s_base_extension_point.html">SBaseExtensionPoint</a> docExtPoint(<span class="stringliteral">&quot;core&quot;</span>, <a class="code" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeabfe976c674a5a708c1373dfdfa3bfa63">SBML_DOCUMENT</a>);</div><div class="line">  <a class="code" href="class_s_base_extension_point.html">SBaseExtensionPoint</a> modelExtPoint(<span class="stringliteral">&quot;core&quot;</span>, <a class="code" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea3c866be107d7858b6dd1e978ed103028">SBML_MODEL</a>);</div><div class="line"></div><div class="line">  <a class="code" href="class_s_base_plugin_creator.html">SBasePluginCreator&lt;GroupsSBMLDocumentPlugin, GroupsExtension&gt;</a> docPluginCreator(docExtPoint, pkgURIs);</div><div class="line">  <a class="code" href="class_s_base_plugin_creator.html">SBasePluginCreator&lt;GroupsModelPlugin, GroupsExtension&gt;</a> modelPluginCreator(modelExtPoint, pkgURIs);</div><div class="line"></div><div class="line">  <span class="comment">// 4. Add the above objects to the SBMLExtension-derived object.</span></div><div class="line"></div><div class="line">  gext.addSBasePluginCreator(&amp;docPluginCreator);</div><div class="line">  gext.addSBasePluginCreator(&amp;modelPluginCreator);</div><div class="line"></div><div class="line">  <span class="comment">// 5. Register the SBMLExtension-derived object with the extension</span></div><div class="line">  <span class="comment">// registry, SBMLExtensionRegistry.</span></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> result = SBMLExtensionRegistry::getInstance().addExtension(&amp;gext);</div><div class="line">  <span class="keywordflow">if</span> (result != <a class="code" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a>)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;[Error] GroupsExtension::init() failed.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Instantiate a global <a class="el" href="class_s_b_m_l_extension_register.html">SBMLExtensionRegister</a> object using the class derived from <a class="el" href="class_s_b_m_l_extension.html">SBMLExtension</a> (discussed above). Here is an example for the Groups package extension, for the object <code>GroupsExtension</code>. This could is placed in the <code>GroupsExtension.cpp</code>: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="class_s_b_m_l_extension_register.html">SBMLExtensionRegister&lt;GroupsExtension&gt;</a> groupsExtensionRegister;</div></div><!-- fragment --><p>The <code>init()</code> method on <code>GroupsExtension</code> is automatically invoked when the "register" object is instantiated. This results in initialization and registration of the package extension with libSBML. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="common-documentation_8h.html">common-documentation.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
