<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Structural Analysis Library: ASTNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Structural Analysis Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ASTNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;ASTNode.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>{core} Abstract Syntax Trees for mathematical expressions.</p>
<p><a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">Abstract Syntax Trees</a> (ASTs) are a simple kind of data structure used in libSBML for storing mathematical expressions. LibSBML ASTs provide a canonical, in-memory representation for all mathematical formulas regardless of their original format (which might be MathML or might be text strings).</p>
<dl class="section user"><dt></dt><dd>An AST <em>node</em> in libSBML is a recursive tree structure; each node has a type, a pointer to a value, and a list of children nodes. Each <a class="el" href="class_a_s_t_node.html">ASTNode</a> node may have none, one, two, or more children depending on its type. There are node types to represent numbers (with subtypes to distinguish integer, real, and rational numbers), names (e.g., constants or variables), simple mathematical operators, logical or relational operators and functions. The following diagram illustrates an example of how the mathematical expression <code>"1 + 2"</code> is represented as an AST with one <em>plus</em> node having two <em>integer</em> children nodes for the numbers <code>1</code> and <code>2</code>. The figure also shows the corresponding MathML representation:</dd></dl>
<p>The following are other noteworthy points about the AST representation in libSBML:</p>
<ul>
<li>A numerical value represented in MathML as a real number with an exponent is preserved as such in the AST node representation, even if the number could be stored in a <code>double</code> data type. This is done so that when an SBML model is read in and then written out again, the amount of change introduced by libSBML to the SBML during the round-trip activity is minimized.</li>
</ul>
<ul>
<li>Rational numbers are represented in an AST node using separate numerator and denominator values. These can be retrieved using the methods ASTNode::getNumerator() and ASTNode::getDenominator().</li>
</ul>
<ul>
<li>The children of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> are other <a class="el" href="class_a_s_t_node.html">ASTNode</a> objects. The list of children is empty for nodes that are leaf elements, such as numbers. For nodes that are actually roots of expression subtrees, the list of children points to the parsed objects that make up the rest of the expression.</li>
</ul>
<p>For many applications, the details of ASTs are irrelevant because libSBML provides text-string based translation functions such as {formulaToL3String, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} and {parseL3Formula, String}. If you find the complexity of using the AST representation of expressions too high for your purposes, perhaps the string-based functions will be more suitable.</p>
<h3><a class="anchor" id="ASTNodeType_t"></a>The set of possible ASTNode types</h3>
<dl class="section user"><dt></dt><dd>Every <a class="el" href="class_a_s_t_node.html">ASTNode</a> has an associated type code to indicate whether, for example, it holds a number or stands for an arithmetic operator.</dd></dl>
<p>The list of possible types is quite long, because it covers all the mathematical functions that are permitted in SBML. The values are shown in the following table:</p>
<p>The types have the following meanings:</p>
<ul>
<li>If the node is basic mathematical operator (e.g., <code>"+"</code>), then the node's type will be {AST_PLUS,ASTNodeType_t}, {AST_MINUS, ASTNodeType_t}, {AST_TIMES, ASTNodeType_t}, {AST_DIVIDE, ASTNodeType_t}, or {AST_POWER, ASTNodeType_t}, as appropriate.</li>
</ul>
<ul>
<li>If the node is a predefined function or operator from SBML Level&#160;1 (in the string-based formula syntax used in Level&#160;1) or SBML Level&#160;2 and&#160;3 (in the subset of MathML used in SBML Levels&#160;2 and&#160;3), then the node's type will be either <code style="margin-right: 0">AST_FUNCTION_</code><span class="placeholder-nospace">X</span>, <code style="margin-right: 0">AST_LOGICAL_</code><span class="placeholder-nospace">X</span>, or <code style="margin-right: 0">AST_RELATIONAL_</code><span class="placeholder-nospace">X</span>, as appropriate. (Examples: {AST_FUNCTION_LOG, ASTNodeType_t}, {AST_RELATIONAL_LEQ, ASTNodeType_t}.)</li>
</ul>
<ul>
<li>If the node refers to a user-defined function, the node's type will be {AST_FUNCTION, ASTNodeType_t} (because it holds the name of the function).</li>
</ul>
<ul>
<li>If the node is a lambda expression, its type will be {AST_LAMBDA, ASTNodeType_t}.</li>
</ul>
<ul>
<li>If the node is a predefined constant (<code>"ExponentialE"</code>, <code>"Pi"</code>, <code>"True"</code> or <code>"False"</code>), then the node's type will be {AST_CONSTANT_E, ASTNodeType_t}, {AST_CONSTANT_PI, ASTNodeType_t}, {AST_CONSTANT_TRUE, ASTNodeType_t}, or {AST_CONSTANT_FALSE, ASTNodeType_t}.</li>
</ul>
<ul>
<li>(Levels&#160;2 and&#160;3 only) If the node is the special MathML csymbol <code>time</code>, the value of the node will be {AST_NAME_TIME, ASTNodeType_t}. (Note, however, that the MathML csymbol <code>delay</code> is translated into a node of type {AST_FUNCTION_DELAY, ASTNodeType_t}. The difference is due to the fact that <code>time</code> is a single variable, whereas <code>delay</code> is actually a function taking arguments.)</li>
</ul>
<ul>
<li>(Level&#160;3 only) If the node is the special MathML csymbol <code>avogadro</code>, the value of the node will be {AST_NAME_AVOGADRO, ASTNodeType_t}.</li>
</ul>
<ul>
<li>(Level&#160;3 Version&#160;2+ only) If the node is the special MathML csymbol <code>rateOf</code>, the value of the node will be {AST_FUNCTION_RATE_OF, ASTNodeType_t}.</li>
</ul>
<ul>
<li>(Level&#160;3 Version&#160;2+ only) If the node is a MathML operator that originates in a package, and is not defined in SBML Leve&#160;3 core, the value of the node will be {AST_ORIGINATES_IN_PACKAGE, ASTNodeType_t}.</li>
</ul>
<ul>
<li>If the node contains a numerical value, its type will be {AST_INTEGER, ASTNodeType_t}, {AST_REAL, ASTNodeType_t}, {AST_REAL_E, ASTNodeType_t}, or {AST_RATIONAL, ASTNodeType_t}, as appropriate.</li>
</ul>
<h3><a class="anchor" id="math-convert"></a>Converting between ASTs and text strings</h3>
<p>The text-string form of mathematical formulas produced by {formulaToString, String} and {formulaToL3String, String}, and read by {parseFormula, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} and {parseL3Formula, <a class="el" href="class_a_s_t_node.html">ASTNode</a>}, are in a simple C-inspired infix notation. A formula in one of these two text-string formats can be handed to a program that understands SBML mathematical expressions, or used as part of a translation system. The libSBML distribution comes with example programs in the <code>"examples"</code> subdirectory that demonstrate such things as translating infix formulas into MathML and vice-versa.</p>
<p>Please see the documentation for the functions {parseFormula, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} and {parseL3Formula, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} for detailed explanations of the infix syntax they accept.</p>
<h3><a class="anchor" id="math-interpretation"></a>Interpretation</h3>
<p>Proper mathematical interpretation of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> requires an understanding of all the allowed MathML operators, the SBML-specific csymbols, and of the named variables in the SBML model. It is important to note that an invalid <a class="el" href="class_a_s_t_node.html">ASTNode</a> might not have a proper mathematical interpretation&ndash;a 'minus' node with three children is simply illegal, and cannot be interpreted. Similarly, a named variable that does not exist in the <a class="el" href="class_model.html">Model</a> also cannot be interpreted. In SBML Level&#160;3 Version&#160;2, the ability was added to reference named variables in MathML that might exist in SBML Level&#160;3 packages. This means that if the software reading the SBML file (or this version of libsbml) does not understand that package, MathML using named variables from those packages will be legal, but will not be interpretable. It is valid to issue a warning in this case, and may be otherwise handled as if an invalid variable name was used. In all cases, the "required" attribute for the package in question must be set to "true".</p>
<h3><a class="anchor" id="math-history"></a>Historical notes</h3>
<p>Readers may wonder why this part of libSBML uses a seemingly less object-oriented design than other parts. Originally, much of libSBML was written in&#160;C. All subsequent development was done in C++, but the complexity of some of the functionality for converting between infix, AST and MathML, coupled with the desire to maintain stability and backward compatibility, means that some of the underlying code is still written in&#160;C. This has lead to the exposed API being more C-like.</p>
<dl class="section see"><dt>See also</dt><dd>{parseL3Formula, String} </dd>
<dd>
{parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
{parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} </dd>
<dd>
{parseFormula, String} </dd>
<dd>
{formulaToL3StringWithSettings, <a class="el" href="class_a_s_t_node.html">ASTNode</a>\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
{formulaToL3String, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} </dd>
<dd>
{formulaToString, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} </dd>
<dd>
{getDefaultL3ParserSettings,} </dd></dl>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_a_s_t_node_8h.html">ASTNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
