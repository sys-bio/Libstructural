<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Structural Analysis Library: L3Parser.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Structural Analysis Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d522931ffa1371640980b621734a4381.html">Users</a></li><li class="navelem"><a class="el" href="dir_e0e46e028fcdb95560c6085655220ac6.html">yosef</a></li><li class="navelem"><a class="el" href="dir_1afb3d56e1abb59d99ac3d455cee0a21.html">Documents</a></li><li class="navelem"><a class="el" href="dir_3033594964cb750f6b4114da55e9651f.html">Visual Studio 2017</a></li><li class="navelem"><a class="el" href="dir_6c17648ef09cec91b866e5c1951578f8.html">Projects</a></li><li class="navelem"><a class="el" href="dir_943a590d2534e8dcb1fca774685a7cb2.html">libstruct</a></li><li class="navelem"><a class="el" href="dir_105279861e378f1f728ec690d292ba0e.html">dependencies</a></li><li class="navelem"><a class="el" href="dir_66f5a8aba67d5153a48e6bf0ce1656a9.html">libsbml-5.15.0-vs2017-release-64</a></li><li class="navelem"><a class="el" href="dir_31470914667ffa0cd174c12045668e75.html">include</a></li><li class="navelem"><a class="el" href="dir_93edcf5f1c2c376d7dc5e22795329c71.html">sbml</a></li><li class="navelem"><a class="el" href="dir_dc8d37295cfa00e46bd335c0e694c932.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">L3Parser.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Definition of the level 3 infix-to-mathml parser C functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="extern_8h.html">sbml/common/extern.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_a_s_t_node_8h.html">sbml/math/ASTNode.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15f1e575d91e220f80ff7828bd3f0e2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="el" href="sbmlfwd_8h.html#a230968dbbf0e6dd9ae871b376484dbb7">L3ParserSettings_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l3_parser_8h.html#a15f1e575d91e220f80ff7828bd3f0e2b">SBML_getDefaultL3ParserSettings</a> ()</td></tr>
<tr class="separator:a15f1e575d91e220f80ff7828bd3f0e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf77ccb651f573bf5b971a783184a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l3_parser_8h.html#a9cbf77ccb651f573bf5b971a783184a2">SBML_getLastParseL3Error</a> ()</td></tr>
<tr class="separator:a9cbf77ccb651f573bf5b971a783184a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dada6a5e7e2caefe1392e792644019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libsbml-namespace_8h.html#a41d9f1012efdaa799c31e8e4ddde0fbd">LIBSBML_CPP_NAMESPACE_BEGIN</a> <a class="el" href="libstructural_8h.html#a004aeed0f22bd5ee77b75a434e2e2a30">BEGIN_C_DECLS</a> <a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="el" href="sbmlfwd_8h.html#addddfd009cab31c5e3e1fd5fdbcb9efa">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l3_parser_8h.html#a51dada6a5e7e2caefe1392e792644019">SBML_parseL3Formula</a> (const char *formula)</td></tr>
<tr class="separator:a51dada6a5e7e2caefe1392e792644019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677d186e2f593a8d95be4118bd33d5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="el" href="sbmlfwd_8h.html#addddfd009cab31c5e3e1fd5fdbcb9efa">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l3_parser_8h.html#a677d186e2f593a8d95be4118bd33d5e4">SBML_parseL3FormulaWithModel</a> (const char *formula, const <a class="el" href="sbmlfwd_8h.html#a88520a7f9fd63e8c8e97b2fb181b91c2">Model_t</a> *model)</td></tr>
<tr class="separator:a677d186e2f593a8d95be4118bd33d5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff165fb711ef63e67be4b5de046c3b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="el" href="sbmlfwd_8h.html#addddfd009cab31c5e3e1fd5fdbcb9efa">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_l3_parser_8h.html#aff165fb711ef63e67be4b5de046c3b91">SBML_parseL3FormulaWithSettings</a> (const char *formula, const <a class="el" href="sbmlfwd_8h.html#a230968dbbf0e6dd9ae871b376484dbb7">L3ParserSettings_t</a> *settings)</td></tr>
<tr class="separator:aff165fb711ef63e67be4b5de046c3b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of the level 3 infix-to-mathml parser C functions. </p>
<dl class="section author"><dt>Author</dt><dd>Lucian Smith </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a15f1e575d91e220f80ff7828bd3f0e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f1e575d91e220f80ff7828bd3f0e2b">&#9670;&nbsp;</a></span>SBML_getDefaultL3ParserSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="el" href="sbmlfwd_8h.html#a230968dbbf0e6dd9ae871b376484dbb7">L3ParserSettings_t</a>* SBML_getDefaultL3ParserSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the default Level&#160;3 ("L3") formula parser settings.</p>
<p>The data structure storing the settings allows callers to change the following parsing behaviors:</p>
<dl class="section user"><dt></dt><dd>The text-string form of mathematical formulas read by the function {parseL3Formula, String} and written by the function {formulaToL3String, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} uses an expanded version of the syntax read and written by {parseFormula, String} and {formulaToString, <a class="el" href="class_a_s_t_node.html">ASTNode</a>}, respectively. The latter two libSBML functions were originally developed to support conversion between SBML Levels&#160;1 and&#160;2, and were focused on the syntax of mathematical formulas used in SBML Level&#160;1. With time, and the use of MathML in SBML Levels&#160;2 and&#160;3, it became clear that supporting Level&#160;2 and&#160;3's expanded mathematical syntax would be useful for software developers. To maintain backwards compatibility for libSBML users, the original {formulaToString, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} and {parseFormula, String} have been left untouched, and instead, the new functionality is provided in the form of {parseL3Formula, String} and {formulaToL3String, <a class="el" href="class_a_s_t_node.html">ASTNode</a>}.</dd></dl>
<p>The following lists the main differences in the formula syntax supported by the "Level 3" or L3 versions of the formula parsers and formatters, compared to what is supported by the Level&#160;1-oriented {parseFormula, String} and {formulaToString, <a class="el" href="class_a_s_t_node.html">ASTNode</a>}:</p>
<ul>
<li>Units may be asociated with bare numbers, using the following syntax: <div style="margin: 10px auto 10px 25px; display: block"> <span class="code" style="background-color: #d0d0ee">number</span> <span class="code" style="background-color: #edd">unit</span> </div> The <span class="code" style="background-color: #d0d0ee">number</span> may be in any form (an integer, real, or rational number), and the <span class="code" style="background-color: #edd">unit</span> must conform to the syntax of an SBML identifier (technically, the type defined as <code>SId</code> in the SBML specifications). The whitespace between <span class="code" style="background-color: #d0d0ee">number</span> and <span class="code" style="background-color: #edd">unit</span> is optional.</li>
</ul>
<ul>
<li>The Boolean function symbols <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, and <code>!=</code> may be used.</li>
</ul>
<ul>
<li>The <em>modulo</em> operation is allowed as the symbol <code>%</code> and will produce a <code>&lt;piecewise&gt;</code> function in the corresponding MathML output.</li>
</ul>
<ul>
<li>All inverse trigonometric functions may be defined in the infix either using <code>arc</code> as a prefix or simply <code>a</code>; in other words, both <code>arccsc</code> and <code>acsc</code> are interpreted as the operator <em>arccosecant</em> as defined in MathML&#160;2.0. (Many functions in the simpler SBML Level&#160;1 oriented parser implemented by {parseFormula, String} are defined this way as well, but not all.)</li>
</ul>
<ul>
<li>The following expression is parsed as a rational number instead of as a numerical division: <pre style="display: block; margin-left: 25px">
   (<span class="code" style="background-color: #d0d0ee">integer</span>/<span class="code" style="background-color: #d0d0ee">integer</span>)</pre> <b>Spaces are not allowed</b> in this construct; in other words, &quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and the operator) will be parsed into the MathML <code>&lt;divide&gt;</code> construct rather than a rational number. You can, however, assign units to a rational number as a whole; here is an example: &quot;<code>(3/4) ml</code>&quot;. (In the case of division rather than a rational number, units are not interpreted in this way.)</li>
</ul>
<ul>
<li>Various parser and formatter behaviors may be altered through the use of a <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object in conjunction with the functions {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} and {formulaToL3StringWithSettings, <a class="el" href="class_a_s_t_node.html">ASTNode</a>\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} The settings available include the following: <ul style="list-style-type: circle">
<li style="margin-bottom: 0.5em">
<p class="startli">The function <code>log</code> with a single argument (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as desired.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Unary minus signs can be collapsed or preserved; that is, sequential pairs of unary minuses (e.g., &quot;<code>- -3</code>&quot;) can be removed from the input entirely and single unary minuses can be incorporated into the number node, or all minuses can be preserved in the AST node structure.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Parsing of units embedded in the input string can be turned on and off.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">The string <code>avogadro</code> can be parsed as a MathML <em>csymbol</em> or as an identifier.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">A <a class="el" href="class_model.html">Model</a> object may optionally be provided to the parser using the variant function call {parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} or stored in a <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object passed to the variant function {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}. When a <a class="el" href="class_model.html">Model</a> object is provided, identifiers (values of type <code>SId</code>) from that model are used in preference to pre-defined MathML definitions for both symbols and functions. More precisely: </p><ul style="list-style-type: square">
<li style="margin-bottom: 0.5em">
<p class="startli"><em>In the case of symbols</em>: the <a class="el" href="class_model.html">Model</a> entities whose identifiers will shadow identical symbols in the mathematical formula are: <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_reaction.html">Reaction</a>, and <a class="el" href="class_species_reference.html">SpeciesReference</a>. For instance, if the parser is given a <a class="el" href="class_model.html">Model</a> containing a <a class="el" href="class_species.html">Species</a> with the identifier &quot;<code>pi</code>&quot;, and the formula to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced will contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct <code>&lt;pi/&gt;</code>.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<em>In the case of user-defined functions</em>: when a <a class="el" href="class_model.html">Model</a> object is provided, <code>SId</code> values of user-defined functions present in the model will be used preferentially over pre-defined MathML functions. For example, if the passed-in <a class="el" href="class_model.html">Model</a> contains a <a class="el" href="class_function_definition.html">FunctionDefinition</a> object with the identifier &quot;<code>sin</code>&quot;, that function will be used instead of the predefined MathML function <code>&lt;sin/&gt;</code>. </li>
</ul>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
An <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object may optionally be provided to identify SBML Level&#160;3 packages that extend the syntax understood by the formula parser. When the namespaces are provided, the parser will interpret possible additional syntax defined by the libSBML plug-ins implementing the SBML Level&#160;3 packages; for example, it may understand vector/array extensions introduced by the SBML Level&#160;3 <em>Arrays</em> package. </li>
</ul>
</li>
</ul>
<p>These configuration settings cannot be changed directly using the basic parser and formatter functions, but <em>can</em> be changed on a per-call basis by using the alternative functions {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} and {formulaToL3StringWithSettings, <a class="el" href="class_a_s_t_node.html">ASTNode</a>\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}.</p>
<p>Neither SBML nor the MathML standard define a "string-form" equivalent to MathML expressions. The approach taken by libSBML is to start with the formula syntax defined by SBML Level&#160;1 (which in fact used a custom text-string representation of formulas, and not MathML), and expand it to include the functionality described above. This formula syntax is based mostly on C programming syntax, and may contain operators, function calls, symbols, and white space characters. The following table provides the precedence rules for the different entities that may appear in formula strings.</p>
<p>In the table above, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the <b>Precedence</b> column show how the order of different types of operation are determined. For example, the expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code> because the <code>*</code> operator has higher precedence. The <b>Associates</b> column shows how the order of similar precedence operations is determined; for example, <code>a &amp;&amp; b || c</code> is evaluated as <code>(a &amp;&amp; b) || c</code> because the <code>&amp;&amp;</code> and <code>||</code> operators are left-associative and have the same precedence.</p>
<p>The function call syntax consists of a function name, followed by optional white space, followed by an opening parenthesis token, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis token. The function name must be chosen from one of the pre-defined functions in SBML or a user-defined function in the model. The following table lists the names of certain common mathematical functions; this table corresponds to Table&#160;6 in the <a href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2" target="_blank">SBML Level&#160;1 Version&#160;2 specification</a> with additions based on the functions added in SBML Level 2 and Level 3:</p>
<p>Parsing of the various MathML functions and constants are all case-insensitive by default: function names such as <code>cos</code>, <code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine operator, <code>&lt;cos&gt;</code>. However, <em>when a <a class="el" href="class_model.html">Model</a> object is used</em> in conjunction with either {parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} or {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}, any identifiers found in that model will be parsed in a case-<em>sensitive</em> way. For example, if a model contains a <a class="el" href="class_species.html">Species</a> having the identifier <code>Pi</code>, the parser will parse &quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi &lt;/ci&gt;</code>&quot; but will continue to parse the symbols &quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as &quot;<code>&lt;pi&gt;</code>&quot;.</p>
<p>As mentioned above, the manner in which the "L3" versions of the formula parser and formatter interpret the function &quot;<code>log</code>&quot; can be changed. To do so, callers should use the function {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} and pass it an appropriate <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object. By default, unlike the SBML Level&#160;1 parser implemented by {parseFormula, String}, the string &quot;<code>log</code>&quot; is interpreted as the base&#160;10 logarithm, and <em>not</em> as the natural logarithm. However, you can change the interpretation to be base-10 log, natural log, or as an error; since the name "log" by itself is ambiguous, you require that the parser uses <code>log10</code> or <code>ln</code> instead, which are more clear. Please refer to {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}.</p>
<p>In addition, the following symbols will be translated to their MathML equivalents, if no symbol with the same <code>SId</code> identifier string exists in the <a class="el" href="class_model.html">Model</a> object provided:</p>
<p>Again, as mentioned above, whether the string &quot;<code>avogadro</code>&quot; is parsed as an AST node of type {AST_NAME_AVOGADRO, ASTNodeType_t} or {AST_NAME, ASTNodeType_t} is configurable; use the version of the parser function called {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}. This Avogadro-related functionality is provided because SBML Level&#160;2 models may not use {AST_NAME_AVOGADRO, ASTNodeType_t} AST nodes.</p>
<p>For more details about the parser, please see the definition of <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> and {parseL3Formula, String}.</p>
<dl class="section see"><dt>See also</dt><dd>{parseL3Formula, String} </dd>
<dd>
{parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
{formulaToL3StringWithSettings, <a class="el" href="class_a_s_t_node.html">ASTNode</a>\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
<a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> </dd></dl>

</div>
</div>
<a id="a9cbf77ccb651f573bf5b971a783184a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbf77ccb651f573bf5b971a783184a2">&#9670;&nbsp;</a></span>SBML_getLastParseL3Error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> char* SBML_getLastParseL3Error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the last error reported by the "L3" mathematical formula parser.</p>
<p>If the functions {parseL3Formula, String}, {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}, or {parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} return <code>NULL</code>, an error is set internally. This function allows callers to retrieve information about the error.</p>
<dl class="section return"><dt>Returns</dt><dd>a string describing the error that occurred. This will contain the input string the parser was trying to parse, the character it had parsed when it encountered the error, and a description of the error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>{parseL3Formula, String} </dd>
<dd>
{parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
{parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} </dd>
<dd>
{getDefaultL3ParserSettings,} </dd></dl>

</div>
</div>
<a id="a51dada6a5e7e2caefe1392e792644019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51dada6a5e7e2caefe1392e792644019">&#9670;&nbsp;</a></span>SBML_parseL3Formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libsbml-namespace_8h.html#a41d9f1012efdaa799c31e8e4ddde0fbd">LIBSBML_CPP_NAMESPACE_BEGIN</a> <a class="el" href="libstructural_8h.html#a004aeed0f22bd5ee77b75a434e2e2a30">BEGIN_C_DECLS</a> <a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="el" href="sbmlfwd_8h.html#addddfd009cab31c5e3e1fd5fdbcb9efa">ASTNode_t</a>* SBML_parseL3Formula </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formula</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a text string as a mathematical formula and returns an AST representation of it.</p>
<dl class="section user"><dt></dt><dd>The text-string form of mathematical formulas read by the function {parseL3Formula, String} and written by the function {formulaToL3String, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} uses an expanded version of the syntax read and written by {parseFormula, String} and {formulaToString, <a class="el" href="class_a_s_t_node.html">ASTNode</a>}, respectively. The latter two libSBML functions were originally developed to support conversion between SBML Levels&#160;1 and&#160;2, and were focused on the syntax of mathematical formulas used in SBML Level&#160;1. With time, and the use of MathML in SBML Levels&#160;2 and&#160;3, it became clear that supporting Level&#160;2 and&#160;3's expanded mathematical syntax would be useful for software developers. To maintain backwards compatibility for libSBML users, the original {formulaToString, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} and {parseFormula, String} have been left untouched, and instead, the new functionality is provided in the form of {parseL3Formula, String} and {formulaToL3String, <a class="el" href="class_a_s_t_node.html">ASTNode</a>}.</dd></dl>
<p>The following lists the main differences in the formula syntax supported by the "Level 3" or L3 versions of the formula parsers and formatters, compared to what is supported by the Level&#160;1-oriented {parseFormula, String} and {formulaToString, <a class="el" href="class_a_s_t_node.html">ASTNode</a>}:</p>
<ul>
<li>Units may be asociated with bare numbers, using the following syntax: <div style="margin: 10px auto 10px 25px; display: block"> <span class="code" style="background-color: #d0d0ee">number</span> <span class="code" style="background-color: #edd">unit</span> </div> The <span class="code" style="background-color: #d0d0ee">number</span> may be in any form (an integer, real, or rational number), and the <span class="code" style="background-color: #edd">unit</span> must conform to the syntax of an SBML identifier (technically, the type defined as <code>SId</code> in the SBML specifications). The whitespace between <span class="code" style="background-color: #d0d0ee">number</span> and <span class="code" style="background-color: #edd">unit</span> is optional.</li>
</ul>
<ul>
<li>The Boolean function symbols <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, and <code>!=</code> may be used.</li>
</ul>
<ul>
<li>The <em>modulo</em> operation is allowed as the symbol <code>%</code> and will produce a <code>&lt;piecewise&gt;</code> function in the corresponding MathML output.</li>
</ul>
<ul>
<li>All inverse trigonometric functions may be defined in the infix either using <code>arc</code> as a prefix or simply <code>a</code>; in other words, both <code>arccsc</code> and <code>acsc</code> are interpreted as the operator <em>arccosecant</em> as defined in MathML&#160;2.0. (Many functions in the simpler SBML Level&#160;1 oriented parser implemented by {parseFormula, String} are defined this way as well, but not all.)</li>
</ul>
<ul>
<li>The following expression is parsed as a rational number instead of as a numerical division: <pre style="display: block; margin-left: 25px">
   (<span class="code" style="background-color: #d0d0ee">integer</span>/<span class="code" style="background-color: #d0d0ee">integer</span>)</pre> <b>Spaces are not allowed</b> in this construct; in other words, &quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and the operator) will be parsed into the MathML <code>&lt;divide&gt;</code> construct rather than a rational number. You can, however, assign units to a rational number as a whole; here is an example: &quot;<code>(3/4) ml</code>&quot;. (In the case of division rather than a rational number, units are not interpreted in this way.)</li>
</ul>
<ul>
<li>Various parser and formatter behaviors may be altered through the use of a <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object in conjunction with the functions {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} and {formulaToL3StringWithSettings, <a class="el" href="class_a_s_t_node.html">ASTNode</a>\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} The settings available include the following: <ul style="list-style-type: circle">
<li style="margin-bottom: 0.5em">
<p class="startli">The function <code>log</code> with a single argument (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as desired.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Unary minus signs can be collapsed or preserved; that is, sequential pairs of unary minuses (e.g., &quot;<code>- -3</code>&quot;) can be removed from the input entirely and single unary minuses can be incorporated into the number node, or all minuses can be preserved in the AST node structure.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Parsing of units embedded in the input string can be turned on and off.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">The string <code>avogadro</code> can be parsed as a MathML <em>csymbol</em> or as an identifier.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">A <a class="el" href="class_model.html">Model</a> object may optionally be provided to the parser using the variant function call {parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} or stored in a <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object passed to the variant function {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}. When a <a class="el" href="class_model.html">Model</a> object is provided, identifiers (values of type <code>SId</code>) from that model are used in preference to pre-defined MathML definitions for both symbols and functions. More precisely: </p><ul style="list-style-type: square">
<li style="margin-bottom: 0.5em">
<p class="startli"><em>In the case of symbols</em>: the <a class="el" href="class_model.html">Model</a> entities whose identifiers will shadow identical symbols in the mathematical formula are: <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_reaction.html">Reaction</a>, and <a class="el" href="class_species_reference.html">SpeciesReference</a>. For instance, if the parser is given a <a class="el" href="class_model.html">Model</a> containing a <a class="el" href="class_species.html">Species</a> with the identifier &quot;<code>pi</code>&quot;, and the formula to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced will contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct <code>&lt;pi/&gt;</code>.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<em>In the case of user-defined functions</em>: when a <a class="el" href="class_model.html">Model</a> object is provided, <code>SId</code> values of user-defined functions present in the model will be used preferentially over pre-defined MathML functions. For example, if the passed-in <a class="el" href="class_model.html">Model</a> contains a <a class="el" href="class_function_definition.html">FunctionDefinition</a> object with the identifier &quot;<code>sin</code>&quot;, that function will be used instead of the predefined MathML function <code>&lt;sin/&gt;</code>. </li>
</ul>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
An <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object may optionally be provided to identify SBML Level&#160;3 packages that extend the syntax understood by the formula parser. When the namespaces are provided, the parser will interpret possible additional syntax defined by the libSBML plug-ins implementing the SBML Level&#160;3 packages; for example, it may understand vector/array extensions introduced by the SBML Level&#160;3 <em>Arrays</em> package. </li>
</ul>
</li>
</ul>
<p>These configuration settings cannot be changed directly using the basic parser and formatter functions, but <em>can</em> be changed on a per-call basis by using the alternative functions {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} and {formulaToL3StringWithSettings, <a class="el" href="class_a_s_t_node.html">ASTNode</a>\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}.</p>
<p>Neither SBML nor the MathML standard define a "string-form" equivalent to MathML expressions. The approach taken by libSBML is to start with the formula syntax defined by SBML Level&#160;1 (which in fact used a custom text-string representation of formulas, and not MathML), and expand it to include the functionality described above. This formula syntax is based mostly on C programming syntax, and may contain operators, function calls, symbols, and white space characters. The following table provides the precedence rules for the different entities that may appear in formula strings.</p>
<p>In the table above, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the <b>Precedence</b> column show how the order of different types of operation are determined. For example, the expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code> because the <code>*</code> operator has higher precedence. The <b>Associates</b> column shows how the order of similar precedence operations is determined; for example, <code>a &amp;&amp; b || c</code> is evaluated as <code>(a &amp;&amp; b) || c</code> because the <code>&amp;&amp;</code> and <code>||</code> operators are left-associative and have the same precedence.</p>
<p>The function call syntax consists of a function name, followed by optional white space, followed by an opening parenthesis token, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis token. The function name must be chosen from one of the pre-defined functions in SBML or a user-defined function in the model. The following table lists the names of certain common mathematical functions; this table corresponds to Table&#160;6 in the <a href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2" target="_blank">SBML Level&#160;1 Version&#160;2 specification</a> with additions based on the functions added in SBML Level 2 and Level 3:</p>
<p>Parsing of the various MathML functions and constants are all case-insensitive by default: function names such as <code>cos</code>, <code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine operator, <code>&lt;cos&gt;</code>. However, <em>when a <a class="el" href="class_model.html">Model</a> object is used</em> in conjunction with either {parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} or {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}, any identifiers found in that model will be parsed in a case-<em>sensitive</em> way. For example, if a model contains a <a class="el" href="class_species.html">Species</a> having the identifier <code>Pi</code>, the parser will parse &quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi &lt;/ci&gt;</code>&quot; but will continue to parse the symbols &quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as &quot;<code>&lt;pi&gt;</code>&quot;.</p>
<p>As mentioned above, the manner in which the "L3" versions of the formula parser and formatter interpret the function &quot;<code>log</code>&quot; can be changed. To do so, callers should use the function {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} and pass it an appropriate <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object. By default, unlike the SBML Level&#160;1 parser implemented by {parseFormula, String}, the string &quot;<code>log</code>&quot; is interpreted as the base&#160;10 logarithm, and <em>not</em> as the natural logarithm. However, you can change the interpretation to be base-10 log, natural log, or as an error; since the name "log" by itself is ambiguous, you require that the parser uses <code>log10</code> or <code>ln</code> instead, which are more clear. Please refer to {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}.</p>
<p>In addition, the following symbols will be translated to their MathML equivalents, if no symbol with the same <code>SId</code> identifier string exists in the <a class="el" href="class_model.html">Model</a> object provided:</p>
<p>Again, as mentioned above, whether the string &quot;<code>avogadro</code>&quot; is parsed as an AST node of type {AST_NAME_AVOGADRO, ASTNodeType_t} or {AST_NAME, ASTNodeType_t} is configurable; use the version of the parser function called {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}. This Avogadro-related functionality is provided because SBML Level&#160;2 models may not use {AST_NAME_AVOGADRO, ASTNodeType_t} AST nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formula</td><td>the text-string formula expression to be parsed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root node of an AST representing the mathematical formula, or <code>NULL</code> if an error occurred while parsing the formula. When <code>NULL</code> is returned, an error is recorded internally; information about the error can be retrieved using {getLastParseL3Error,}.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>{parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
{parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} </dd>
<dd>
{parseFormula, String} </dd>
<dd>
{formulaToL3StringWithSettings, <a class="el" href="class_a_s_t_node.html">ASTNode</a>\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
{formulaToL3String, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} </dd>
<dd>
{formulaToString, <a class="el" href="class_a_s_t_node.html">ASTNode</a>} </dd>
<dd>
<a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> </dd>
<dd>
{getDefaultL3ParserSettings,} </dd>
<dd>
{getLastParseL3Error,}</dd></dl>
<dl class="section note"><dt>Note</dt><dd>We urge developers to keep in mind that the text-string formula syntax is specific to libSBML. <em>Neither MathML nor SBML define a text-string format for mathematical formulas.</em> LibSBML's particular syntax should not be considered to be a canonical or standard general-purpose mathematical expression syntax. LibSBML provides methods for parsing and transforming text-string math formulas back and forth from AST structures for the convenience of calling applications, but it is important to keep the system's limitations in mind. </dd></dl>

</div>
</div>
<a id="a677d186e2f593a8d95be4118bd33d5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677d186e2f593a8d95be4118bd33d5e4">&#9670;&nbsp;</a></span>SBML_parseL3FormulaWithModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="el" href="sbmlfwd_8h.html#addddfd009cab31c5e3e1fd5fdbcb9efa">ASTNode_t</a>* SBML_parseL3FormulaWithModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sbmlfwd_8h.html#a88520a7f9fd63e8c8e97b2fb181b91c2">Model_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a text string as a mathematical formula using a <a class="el" href="class_model.html">Model</a> to resolve symbols, and returns an AST representation of the result.</p>
<p>This is identical to {parseL3Formula, String}, except that this function uses the given model in the argument <code>model</code> to check against identifiers that appear in the <code>formula</code>. For more information about the parser, please see the definition of <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> and the function {parseL3Formula, String}.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formula</td><td>the mathematical formula expression to be parsed.</td></tr>
    <tr><td class="paramname">model</td><td>the <a class="el" href="class_model.html">Model</a> object to use for checking identifiers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root node of an AST representing the mathematical formula, or <code>NULL</code> if an error occurred while parsing the formula. When <code>NULL</code> is returned, an error is recorded internally; information about the error can be retrieved using {getLastParseL3Error,}.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>{parseL3Formula, String} </dd>
<dd>
{parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
{parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} </dd>
<dd>
{parseFormula, String} </dd>
<dd>
{getLastParseL3Error,} </dd>
<dd>
<a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> </dd></dl>

</div>
</div>
<a id="aff165fb711ef63e67be4b5de046c3b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff165fb711ef63e67be4b5de046c3b91">&#9670;&nbsp;</a></span>SBML_parseL3FormulaWithSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="extern_8h.html#a8e9e5118f0c55d410f8bc217f2954dbf">LIBSBML_EXTERN</a> <a class="el" href="sbmlfwd_8h.html#addddfd009cab31c5e3e1fd5fdbcb9efa">ASTNode_t</a>* SBML_parseL3FormulaWithSettings </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sbmlfwd_8h.html#a230968dbbf0e6dd9ae871b376484dbb7">L3ParserSettings_t</a> *&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a text string as a mathematical formula using specific parser settings and returns an AST representation of the result.</p>
<p>This is identical to {parseL3Formula, String}, except that this function uses the parser settings given in the argument <code>settings</code>. The settings override the default parsing behavior. The following parsing behaviors can be configured:</p>
<ul>
<li>A <a class="el" href="class_model.html">Model</a> object may optionally be provided to use identifiers (values of type <code>SId</code>) from the model in preference to pre-defined MathML symbols More precisely, the <a class="el" href="class_model.html">Model</a> entities whose identifiers will shadow identical symbols in the mathematical formula are: <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_reaction.html">Reaction</a>, and <a class="el" href="class_species_reference.html">SpeciesReference</a>. For instance, if the parser is given a <a class="el" href="class_model.html">Model</a> containing a <a class="el" href="class_species.html">Species</a> with the identifier &quot;<code>pi</code>&quot;, and the formula to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced by the parser will contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct <code>&lt;pi/&gt;</code>. Another example, if the passed-in <a class="el" href="class_model.html">Model</a> contains a <a class="el" href="class_function_definition.html">FunctionDefinition</a> with the identifier &quot;<code>sin</code>&quot;, that function will be used instead of the predefined MathML function <code>&lt;sin/&gt;</code>. </li>
<li>The function <code>log</code> with a single argument (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as desired. </li>
<li>Unary minus signs can be either collapsed or preserved; that is, the parser can either (1) remove sequential pairs of unary minuses (e.g., &quot;<code>- -3</code>&quot;) from the input and incorporate single unary minuses into the number node, or (2) preserve all minuses in the AST node structure, turning them into <a class="el" href="class_a_s_t_node.html">ASTNode</a> objects of type {AST_MINUS, ASTNodeType_t}. </li>
<li>The character sequence &quot;<code>number id</code>&quot; can be interpreted as a numerical value <code>number</code> followed by units of measurement indicated by <code>id</code>, or it can be treated as a syntax error. (In Level&#160;3, MathML <code>&lt;cn&gt;</code> elements can have an attribute named <code>units</code> placed in the SBML namespace, which can be used to indicate the units to be associated with the number. The text-string infix formula parser allows units to be placed after raw numbers; they are interpreted as unit identifiers for units defined by the SBML specification or in the containing <a class="el" href="class_model.html">Model</a> object.) </li>
<li>The symbol <code>avogadro</code> can be parsed either as a MathML <em>csymbol</em> or as a identifier. More specifically, &quot;<code>avogadro</code>&quot; can be treated as an <a class="el" href="class_a_s_t_node.html">ASTNode</a> of type {AST_NAME_AVOGADRO, ASTNodeType_t} or of type {AST_NAME, ASTNodeType_t}. </li>
<li>Strings that match built-in functions and constants can either be parsed as a match regardless of capitalization, or may be required to be all-lower-case to be considered a match. </li>
<li>LibSBML plug-ins implementing support for SBML Level&#160;3 packages may introduce extensions to the syntax understood by the parser. The precise nature of the extensions will be documented by the individual package plug-ins. An example of a possible extension is a notation for vectors and arrays, introduced by the SBML Level&#160;3 <em>Arrays</em> package.</li>
</ul>
<p>For more details about the parser, please see the definition of <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> and {parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>}.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formula</td><td>the mathematical formula expression to be parsed.</td></tr>
    <tr><td class="paramname">settings</td><td>the settings to be used for this parser invocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root node of an AST representing the mathematical formula, or <code>NULL</code> if an error occurred while parsing the formula. When <code>NULL</code> is returned, an error is recorded internally; information about the error can be retrieved using {getLastParseL3Error,}.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>{parseL3Formula, String} </dd>
<dd>
{parseL3FormulaWithSettings, String\, <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a>} </dd>
<dd>
{parseL3FormulaWithModel, String\, <a class="el" href="class_model.html">Model</a>} </dd>
<dd>
{parseFormula, String} </dd>
<dd>
{getLastParseL3Error,} </dd>
<dd>
<a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
